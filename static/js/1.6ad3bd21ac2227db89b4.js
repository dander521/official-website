webpackJsonp([1],{

/***/ "1MxG":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/img/banner1.3788b4e.png";

/***/ }),

/***/ "1SrM":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "3HfK":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "7/Ek":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/img/banner2.4d89479.jpg";

/***/ }),

/***/ "81Ru":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "GY21":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "M3eK":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/img/img1.51364f1.png";

/***/ }),

/***/ "QbkR":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/img/logo_toyota.14aeb91.png";

/***/ }),

/***/ "TIoG":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAATwklEQVR4Xu2de5QkdXXHv7d79tFTPV3NY7saRR5G8AACmhBE4JzE5REUY4K8wiGCCZKQKMYgJCJESEQgMcFECImJh0TIITzVmENQFDhENwokykMPSTRG1gS6eli2q6eqZ3d2um5O77hkYR9TVVP3V7+avv3v/n7f372fX3+2prvrQdCXElACuyRAykYJKIFdE1BB9N2hBHZDQAXRt4cSUEH0PaAEshHQI0g2bjprTAioIGOy0dpmNgIqSDZuOmtMCKggY7LR2mY2AipINm46a0wIqCBjstHaZjYCKkg2bjprTAioIGOy0dpmNgIqSDZuOmtMCKggY7LR2mY2AipINm46a0wIqCBjstHaZjYCKkg2bjprTAioIGOy0dpmNgIqSDZuOmtMCKggY7LR2mY2AipINm46a0wIqCBjstHaZjYCKkg2bjprTAioIGOy0dpmNgIqSDZuO87awI1Vw75HoDaBvCridoyJdYOW8+28lhjnHKcbtgG0wUMPNGLMbthyPyXNRAVJSdjphIcDw8OJcDADB4HxOiI+BKCpV0bFTBcO2o3PpFxifId32HEQHUOV4SEc4yBgxBavB/ATO0BhvBi23b2kYakgixBe3Zk9sIItJxB4LQhrCfCSbooKsggp5pX1F8JjEcdrAaxl4GgCViTjy73Qa+6RbGz2USrITtjVN8wcivn4LDDOBOHQrHhVkJ2QY15V6868vcJ8FhG/A6B6Nr4qSDZuWWdt5ObkXP/iCnDe6NCeNWb7eSrI/9OoT8/8DMfxe8H8LiKaXDpf3hh6zT2XnrP7hLE/gkxOR/tQPH8pgX8t+/9mO4esggCT08GplRiXAzgu3zezHkHy5fmKtNqLs/tVt2y+EqALpRYaZ0Hq3d7ZHONKInqDDF89gohwrb0weHV1uOVKBi5I/oEwWynjKEjN759WQXw1gY7IRi3pLD2CJCWVbBxzzfH71xHht5JNWPqocRKk5vePqyC+iUBvXDq5JAl6BElCKdGY2gvB0ZV5vpOIDkg0IadBYyEI80qnG3wcoEsIqOSELkGMHkESQFpkSGGbt1DXchfE8cMjCMO7gK0/5hl+qSBLAr7a7722yvRFIhy2pKAlTF7Ogjh+/0MAXyf9OW7X+FWQzG9Np9t/D+L4JiJyMofkMHFZCrKRm85c/04CTs4B0RIiVJBM8Bw/uJWAd2eanPOk5SZIrRO8uUL4Ao1OGiz8pR/S023BBm7U5/tfAvCWdBPlRi8nQSY7/XcSRl90YLUcsTTJegRJTOvHv208WMyHxV2XuVwEmfR7FxHoZgIsOvNCBUkkyKpucNAE4xEC9kk0weCg5SBI3Q+uAnC1QWzJltLT3RfnVNsw2Lcyv+UxG+VYDl/zjr6pIvAfL74TRYzQI8huqW+9wiye/xciOrCI7UmyZpmPIPVu8D4wbkrSZzFjVJBdc9/Izfpc/1EABxezOclWLasgTrf/K8R8S7IuCxqlf2LtAjzzKsfv/zMRji5oaxIvW0ZB6tMzb+U4/goB1cSNFjJQjyA7Ymcmp9v/JwJOKWRPUi5aNkGcbvhGxPNfL/oH1mSYVZAdODl+73oC/W4ygMWPKpMgC5/phk8SoVU8uQQV6J9YL4fk+MHPETD6IbA0rzIJUveDr+d/1Z/kVukR5CW6k9PRqyrxlu8C1JREnnd2WQSZ9IOPVoDfz7t/2TwV5CW+5fvfbaH0MghS6/aPrzJ/TfbNLJGu52Jtper4/csI/EcSiKUzrReEedLxg2eIaD9pFvnn6xEEq6b7r58Y8lNEWJk/YPlE2wWp+/2/BPjX5UlIrKCCwOkEjxPhKAm88pl8b1xZce1gjfMt+bXSrzD6vQNx/FD6mVbM+E8w3RO2G1dIV2PR2Zkvb3V0BmkF9BfSAHLO/34MvmFA7m1oUZhzdq5xdT/4D9vPRHhlwwzcGoP+atZrrMsVxm7C7BSky/U6B+sBEr/3ah6gGfztGJWPzXqNz+eRJ53hdIIPEuGT0uvkkc+MzUS4ZTix4trZvSb/J4/MNBlWCuL4wQ0E/HaaRooYy8w/pCpdHq5x7yhi/Uxrbj2Pbet/PjvcjT5TntAkBhjA38cTKz48u9fkj4SWWTTWOkFGN1uYAP3XopUXPICJL49azesLLiP18pOd4MYK4f2pJxqcwOAnuUoXDvZ2Hze47E6Xsk6Qut+7F6B3FQ1ml+szP7KFcMFmr2m9xK/sYVU3eN0KxvesZYvRYYMui7yGNdegWCXI6KYAVcI3bd1ABm6IWo3LQBTbWuPu6nI6weg2SD9vY+0MPAeqnhq16k/YVJ9Vgjid4FFbT2Nn4PzIc2+1afPS1GLzL+bM+FdC5dSwPdVN05OJsdYIUu/MrAXFoxsvWPViYMhMpw/ajX+wqrCUxTh+cL+Nlwkw+KmI3WPRpihlS0aGWyOI4wdfLv5mZC9nzkBMxOeErebo9pqlfdU3zByG+fg71jXAeCZczceh2dxoXW0/LsgKQUYX6hAP7XsaLOHisOVafF12sreV4wd/R8C5yUabGcXMz5JT/elwamrazIrZVrFDED/4LC08+syaFzP/TdRu/qo1BWUspN6ZaTHFz5u98/rui2XmaMtE5ai5vRv/nrEtY9OKF6TX28PZRM8TYZWxrhdbiPmR0HPXlvXbqu3bq/vB6J5Wo3tbWfFa+AGQT4685letKGiRIgoXxL7T2TkIV+FAm/8uTvzGWriGf3T0SPzo6sTZGQcy8MnIcy/JON34tOIF6fR+YNO9rRg4L/Lc24zvhMCCte7MGVWO7xaIzhQ5+twRee4hIJrNFFDApEIFcfzeiQT6SgF973RJBj8Yec0TbalnqXXY9s3gEHS8yTNxl8pvNL9YQTrBHUQ4O49G8siY55Wv3dSu/XceWUVnrN44e8DE3JxFvfDdodc8q2guadcvTpCFuyNa8/03A7dFnmvVN2lpN/MVH87/AMDvLSUjz7mM6pGRV38qz0wTWYUJUveD3wTw5yaaXGyN0dcq84SDN7fc7y82tiz/7vi9HxFoXxvqZcY/Rm33nTbUkraGIgUZ3Unj+LQFy4zne0KveaZMtvnUWic4pkr4hvmVd75iTBM/OWg59v0QnABQIYLUZ2bW8CD2bXkgC4NPKsv38gn2dHQt/5+afB787mpi8BOR13xTkrptHFOMIN3gA2D8mR1AeCZsuc3l8KPgNp6OHzxnyzNTYuCqgeeOPg+V8lWIII7f+yqBTrCB2OhGAJHnnm9DLXnUMNmN3lTheXvupMKVw8P2lH0nSiaEbV6QaZ5y4v5GW26vHzP9YtlPZd9+r226jSgzr4/azf0TvhetHGZckJo/c3oV8T220AhbjRqINtlSz1LrcDrBN4nw5qXm5DGfwZ+IvObv5JFVVIZxQep+MLrX1UVFNbz9usx4NGq7x9hQSy41jG4l2u2Htnz5MUTljFlv6t5ceisopAhBrLlhWcy4adB2Ly6Ife7Ljp5lXiG25srH4YqV+8/uWVufe6MGA40KMjkd7VOJ558z2N9ul1pOJyaOGrXp610wNoRtd29b9jprHUYFcTrBOUS4PWuxec+bq1YOndt76pm8c4vKc/zetwhkxW8OzLgvarvvKIpFXusaFWTSD26qAO/Lq/il5oSea7T/pda72/nTPFWP+33RNVKEM9P1UbtxeYopVg41+gZxOr2niegNNpBgoBN57j421JJHDbY9oo4Zl0RttxT3/90df3OCbL0hdX8mjzdDHhkMfjrymkfkkWVDRt0PRo9Q+6gNtYxqWC6f74wJ4vi9kwj0gDUbyPxQ1G5a8Wt+HkwcP3iAgJPyyMojgwlvi1puqR66urO+jQky2eldUSG6Jg/4eWQw446o7Z6TR5YNGXW/FwDUsKGWUQ1lPoN3e4bGBKn7vc8BdJo1G8i4cdB2P2BLPUupw8abUi+H30BGe2JMEKfTe9ayh0XeHHquNd+oLUWQerd3NpisekbJ/MqVB27ao/bDpfRlw1wzgjBP1rt9q+69upwusa13g2vAEH9eX5o3LHP1iKhdfzrNHBvHGhHEtivcFjaCPxd6zdNt3JS0Ndn4TJUh4y2zbdfaR1kkZWxEEKfbP5+Y/zZpUSbGMfClyHPfZmIt6TWcTvAdIhwmvU6qfK6cELanyvoU3ZdaNSKIjX8CAFgXeq4l18SneuvtMNjpBJusunXr6FusZXKdjRFBnE5wOxGs+kq17NdKb7OktmGwb3V+S2EPudyV2sw4N2q71px3l/W/ICOC1P1g9FzrY7MWac08xjQTPw/Q00T8xTB27yv6wS82Pzkqzb4xYxPAHSIayf5wTBNfsOFOKEYEsekmAmk2bbGxzDyLCn2aaeITgzVOIafxO37wywQsi3sJ78Cb8QwTrivyXsnygjBXnW5/iy1XuS32ps/y71tFIfxC5DWN32d4stP7SIXo41nqLtGcdSE1TkGLQtM1iwuyeuPs/hNzc6X/wSjRxhD/Uthq3plobE6DbLuEIKe2dnIw4SeiWuVENBobpNbYWa64ILY/2jlv2KZP0qv7vXsAWha/5yy2F8x4LPIaP2vy8Qnigjjd4BRi3L9Y88vl30ePF5uvVn5q85rG6Np78ZdN9xgTb3brAmbvEi8uSG3D4DXV+S2lvnA/7cYz88NRu7k27bws4yc7wY0VwvuzzC3rnJjw9kHLNfKfrrggk9PRqyrx/P+WdTOy1m3qTy2rbtSQFVb6ed8LPffg9NPSz1BB0jNLNMPUU3LHVBDA0C1NVZBEb/cMgxjTYdttZZiZasq4CsLEH45azT9MBSvDYBUkA7SkU+ZXrjxg0x61Z5OOzzJuXAUB+N7Qa56RhVmaOSpIGlppx1Yqa8M1Uw+nnZZm/LgKwuB/i7zmUWlYZRmrgmShlnAOE70najU+m3B4pmFjKwijG7Vd8ee/qyCZ3pbJJsVMFw7ajc8kG51t1LgKAnAv9Jp7ZKOWfJYKkpxV6pEqSGpkKSaoIClg2TlUBZHcFxVEkq6RbBVEErMKIknXSLYKIolZBZGkayRbBZHErIJI0jWSrYJIYlZBJOkayVZBJDGrIJJ0jWSrIJKYVRBJukayVRBJzCqIJF0j2SqIJGYVRJKukWwVRBKzCiJJ10i2CiKJWQWRpGskWwWRxKyCSNI1kq2CSGJWQSTpGslWQSQxqyCSdI1kqyCSmFUQSbpGslUQScwqiCRdI9kqiCRmFUSSrpFsFUQSswoiSddItgoiiVkFkaRrJFsFkcSsgkjSNZKtgkhiVkEk6RrJVkEkMasgknSNZKsgkphVEEm6RrJVEEnMKogkXSPZKogkZhVEkq6RbBVEErMKIknXSLYKIolZBZGkayRbBZHErIJI0jWSrYJIYlZBJOkayVZBJDGrIJJ0jWSrIJKYVRBJukayVRBJzCqIJF0j2SqIJGYVRJKukWwVRBKzCiJJ10i2CiKJWQWRpGskWwWRxKyCSNI1kq2CSGJWQSTpGslWQSQxqyCSdI1kqyCSmFUQSbpGslUQScwqiCRdI9kqiCTmZSIIpnmqHvf7kqiszSY+O2w175Ksr94NPgbGlZJr2JjNzOujdnN/6dpIeoFRvtPphUTkmFjLpjWGoONnvcY6yZom/d5vVEA3S65hafY3Qs89Vro2M4L4vacIdLh0M7blM1X3iVr1jmRdTjc4hRj3S65hYzYDt0Wee550bWYE6fSvJeLLpZuxKZ8Zj0dt92jxmphXOH4QEFFNfC2bFiA+K2w175YuyYwgfngkYfiEdDM25TPoQ5HXuMFETU4nuJ0I55hYy4Y1mHkQee7eIJqVrseIIFs/h/jBAwScJN2QFfmMF0Ov8RoQDUzU4/jhEYThkybWsmINpmvDduMKE7UYFGR8NpFBl0Ze409MbOC2Nep+7y6AzjS5ZjFrcRBOuPthLzLyzagxQUYw635wNYCrigFrZlVmfijy3JNBNDSz4sIq9c5MizF8jIjEv/o02df2azEwYnpq5LlfNlWDUUEWNrL31yB6r6kGTa6z9YM5Gm9FmyKT625ba1U3OGhFjHUgrClifek1Y6ILBq3GLdLrbJ9vXJCFzyP9ywC+joCqyWZl1+J7wpZ7LojmZNfZfXrthcGrK8O5+wh0ZJF15Ls2B8wTp0ft+oP55i6eVoggo7Jq3f7x1Zg/DcKhi5dp8QjGNBMujTz3VpuqrHeDa8Aw8kFWtm/+/HDFqg/O7llbL7vOztMLE2RbOZN+76IK6N0AxH8VzRMwM77LhDsH3LihqD+pFutn9cbZ/SfmNn8ETKeV6c+u0de4RHgAleqnwjVTDy/Wp+S/Fy7ItuZGHzJRLcfRZD4ert/kNX8guTF5Z09O946qoFrPOzfvvHnm4aZW42t552bNs0aQrA3oPCUgSUAFkaSr2aUnoIKUfgu1AUkCKogkXc0uPQEVpPRbqA1IElBBJOlqdukJqCCl30JtQJKACiJJV7NLT0AFKf0WagOSBFQQSbqaXXoCKkjpt1AbkCSggkjS1ezSE1BBSr+F2oAkARVEkq5ml56AClL6LdQGJAmoIJJ0Nbv0BFSQ0m+hNiBJQAWRpKvZpSeggpR+C7UBSQIqiCRdzS49ARWk9FuoDUgSUEEk6Wp26QmoIKXfQm1AkoAKIklXs0tPQAUp/RZqA5IEVBBJuppdegIqSOm3UBuQJKCCSNLV7NITUEFKv4XagCQBFUSSrmaXnoAKUvot1AYkCaggknQ1u/QEVJDSb6E2IElABZGkq9mlJ6CClH4LtQFJAiqIJF3NLj0BFaT0W6gNSBL4P97jcUHwuOcWAAAAAElFTkSuQmCC"

/***/ }),

/***/ "bhvW":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "blpe":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "mTCC":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "uRyO":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// CONCATENATED MODULE: ./node_modules/dom7/node_modules/ssr-window/dist/ssr-window.esm.js
/**
 * SSR Window 2.0.0
 * Better handling for window object in SSR environment
 * https://github.com/nolimits4web/ssr-window
 *
 * Copyright 2020, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: May 12, 2020
 */
/* eslint-disable no-param-reassign */
function isObject(obj) {
    return (obj !== null &&
        typeof obj === 'object' &&
        'constructor' in obj &&
        obj.constructor === Object);
}
function extend(target, src) {
    if (target === void 0) { target = {}; }
    if (src === void 0) { src = {}; }
    Object.keys(src).forEach(function (key) {
        if (typeof target[key] === 'undefined')
            target[key] = src[key];
        else if (isObject(src[key]) &&
            isObject(target[key]) &&
            Object.keys(src[key]).length > 0) {
            extend(target[key], src[key]);
        }
    });
}

var doc = typeof document !== 'undefined' ? document : {};
var ssrDocument = {
    body: {},
    addEventListener: function () { },
    removeEventListener: function () { },
    activeElement: {
        blur: function () { },
        nodeName: '',
    },
    querySelector: function () {
        return null;
    },
    querySelectorAll: function () {
        return [];
    },
    getElementById: function () {
        return null;
    },
    createEvent: function () {
        return {
            initEvent: function () { },
        };
    },
    createElement: function () {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute: function () { },
            getElementsByTagName: function () {
                return [];
            },
        };
    },
    createElementNS: function () {
        return {};
    },
    importNode: function () {
        return null;
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
    },
};
extend(doc, ssrDocument);

var win = typeof window !== 'undefined' ? window : {};
var ssrWindow = {
    document: ssrDocument,
    navigator: {
        userAgent: '',
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
    },
    history: {
        replaceState: function () { },
        pushState: function () { },
        go: function () { },
        back: function () { },
    },
    CustomEvent: function CustomEvent() {
        return this;
    },
    addEventListener: function () { },
    removeEventListener: function () { },
    getComputedStyle: function () {
        return {
            getPropertyValue: function () {
                return '';
            },
        };
    },
    Image: function () { },
    Date: function () { },
    screen: {},
    setTimeout: function () { },
    clearTimeout: function () { },
    matchMedia: function () {
        return {};
    },
};
extend(win, ssrWindow);



// CONCATENATED MODULE: ./node_modules/dom7/dist/dom7.modular.js
/**
 * Dom7 2.1.5
 * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
 * http://framework7.io/docs/dom.html
 *
 * Copyright 2020, Vladimir Kharlampidi
 * The iDangero.us
 * http://www.idangero.us/
 *
 * Licensed under MIT
 *
 * Released on: May 15, 2020
 */


class Dom7 {
  constructor(arr) {
    const self = this;
    // Create array-like object
    for (let i = 0; i < arr.length; i += 1) {
      self[i] = arr[i];
    }
    self.length = arr.length;
    // Return collection with methods
    return this;
  }
}

function $(selector, context) {
  const arr = [];
  let i = 0;
  if (selector && !context) {
    if (selector instanceof Dom7) {
      return selector;
    }
  }
  if (selector) {
      // String
    if (typeof selector === 'string') {
      let els;
      let tempParent;
      const html = selector.trim();
      if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
        let toCreate = 'div';
        if (html.indexOf('<li') === 0) toCreate = 'ul';
        if (html.indexOf('<tr') === 0) toCreate = 'tbody';
        if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
        if (html.indexOf('<tbody') === 0) toCreate = 'table';
        if (html.indexOf('<option') === 0) toCreate = 'select';
        tempParent = doc.createElement(toCreate);
        tempParent.innerHTML = html;
        for (i = 0; i < tempParent.childNodes.length; i += 1) {
          arr.push(tempParent.childNodes[i]);
        }
      } else {
        if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
          // Pure ID selector
          els = [doc.getElementById(selector.trim().split('#')[1])];
        } else {
          // Other selectors
          els = (context || doc).querySelectorAll(selector.trim());
        }
        for (i = 0; i < els.length; i += 1) {
          if (els[i]) arr.push(els[i]);
        }
      }
    } else if (selector.nodeType || selector === win || selector === doc) {
      // Node/element
      arr.push(selector);
    } else if (selector.length > 0 && selector[0].nodeType) {
      // Array of elements or instance of Dom
      for (i = 0; i < selector.length; i += 1) {
        arr.push(selector[i]);
      }
    }
  }
  return new Dom7(arr);
}

$.fn = Dom7.prototype;
$.Class = Dom7;
$.Dom7 = Dom7;

function unique(arr) {
  const uniqueArray = [];
  for (let i = 0; i < arr.length; i += 1) {
    if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
  }
  return uniqueArray;
}
function toCamelCase(string) {
  return string.toLowerCase().replace(/-(.)/g, (match, group1) => group1.toUpperCase());
}

function requestAnimationFrame(callback) {
  if (win.requestAnimationFrame) return win.requestAnimationFrame(callback);
  else if (win.webkitRequestAnimationFrame) return win.webkitRequestAnimationFrame(callback);
  return win.setTimeout(callback, 1000 / 60);
}
function cancelAnimationFrame(id) {
  if (win.cancelAnimationFrame) return win.cancelAnimationFrame(id);
  else if (win.webkitCancelAnimationFrame) return win.webkitCancelAnimationFrame(id);
  return win.clearTimeout(id);
}

// Classes and attributes
function addClass(className) {
  if (typeof className === 'undefined') {
    return this;
  }
  const classes = className.split(' ');
  for (let i = 0; i < classes.length; i += 1) {
    for (let j = 0; j < this.length; j += 1) {
      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.add(classes[i]);
    }
  }
  return this;
}
function removeClass(className) {
  const classes = className.split(' ');
  for (let i = 0; i < classes.length; i += 1) {
    for (let j = 0; j < this.length; j += 1) {
      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.remove(classes[i]);
    }
  }
  return this;
}
function hasClass(className) {
  if (!this[0]) return false;
  return this[0].classList.contains(className);
}
function toggleClass(className) {
  const classes = className.split(' ');
  for (let i = 0; i < classes.length; i += 1) {
    for (let j = 0; j < this.length; j += 1) {
      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.toggle(classes[i]);
    }
  }
  return this;
}
function attr(attrs, value) {
  if (arguments.length === 1 && typeof attrs === 'string') {
    // Get attr
    if (this[0]) return this[0].getAttribute(attrs);
    return undefined;
  }

  // Set attrs
  for (let i = 0; i < this.length; i += 1) {
    if (arguments.length === 2) {
      // String
      this[i].setAttribute(attrs, value);
    } else {
      // Object
      // eslint-disable-next-line
      for (const attrName in attrs) {
        this[i][attrName] = attrs[attrName];
        this[i].setAttribute(attrName, attrs[attrName]);
      }
    }
  }
  return this;
}
// eslint-disable-next-line
function removeAttr(attr) {
  for (let i = 0; i < this.length; i += 1) {
    this[i].removeAttribute(attr);
  }
  return this;
}
// eslint-disable-next-line
function dom7_modular_prop(props, value) {
  if (arguments.length === 1 && typeof props === 'string') {
    // Get prop
    if (this[0]) return this[0][props];
  } else {
    // Set props
    for (let i = 0; i < this.length; i += 1) {
      if (arguments.length === 2) {
        // String
        this[i][props] = value;
      } else {
        // Object
        // eslint-disable-next-line
        for (const propName in props) {
          this[i][propName] = props[propName];
        }
      }
    }
    return this;
  }
}
function dom7_modular_data(key, value) {
  let el;
  if (typeof value === 'undefined') {
    el = this[0];
    // Get value
    if (el) {
      if (el.dom7ElementDataStorage && (key in el.dom7ElementDataStorage)) {
        return el.dom7ElementDataStorage[key];
      }

      const dataKey = el.getAttribute(`data-${key}`);
      if (dataKey) {
        return dataKey;
      }
      return undefined;
    }
    return undefined;
  }

  // Set value
  for (let i = 0; i < this.length; i += 1) {
    el = this[i];
    if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
    el.dom7ElementDataStorage[key] = value;
  }
  return this;
}
function removeData(key) {
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {
      el.dom7ElementDataStorage[key] = null;
      delete el.dom7ElementDataStorage[key];
    }
  }
}
function dataset() {
  const el = this[0];
  if (!el) return undefined;
  const dataset = {}; // eslint-disable-line
  if (el.dataset) {
    // eslint-disable-next-line
    for (const dataKey in el.dataset) {
      dataset[dataKey] = el.dataset[dataKey];
    }
  } else {
    for (let i = 0; i < el.attributes.length; i += 1) {
      // eslint-disable-next-line
      const attr = el.attributes[i];
      if (attr.name.indexOf('data-') >= 0) {
        dataset[toCamelCase(attr.name.split('data-')[1])] = attr.value;
      }
    }
  }
  // eslint-disable-next-line
  for (const key in dataset) {
    if (dataset[key] === 'false') dataset[key] = false;
    else if (dataset[key] === 'true') dataset[key] = true;
    else if (parseFloat(dataset[key]) === dataset[key] * 1) dataset[key] *= 1;
  }
  return dataset;
}
function val(value) {
  const dom = this;
  if (typeof value === 'undefined') {
    if (dom[0]) {
      if (dom[0].multiple && dom[0].nodeName.toLowerCase() === 'select') {
        const values = [];
        for (let i = 0; i < dom[0].selectedOptions.length; i += 1) {
          values.push(dom[0].selectedOptions[i].value);
        }
        return values;
      }
      return dom[0].value;
    }
    return undefined;
  }

  for (let i = 0; i < dom.length; i += 1) {
    const el = dom[i];
    if (Array.isArray(value) && el.multiple && el.nodeName.toLowerCase() === 'select') {
      for (let j = 0; j < el.options.length; j += 1) {
        el.options[j].selected = value.indexOf(el.options[j].value) >= 0;
      }
    } else {
      el.value = value;
    }
  }
  return dom;
}
// Transforms
// eslint-disable-next-line
function dom7_modular_transform(transform) {
  for (let i = 0; i < this.length; i += 1) {
    const elStyle = this[i].style;
    elStyle.webkitTransform = transform;
    elStyle.transform = transform;
  }
  return this;
}
function transition(duration) {
  if (typeof duration !== 'string') {
    duration = `${duration}ms`; // eslint-disable-line
  }
  for (let i = 0; i < this.length; i += 1) {
    const elStyle = this[i].style;
    elStyle.webkitTransitionDuration = duration;
    elStyle.transitionDuration = duration;
  }
  return this;
}
// Events
function on(...args) {
  let [eventType, targetSelector, listener, capture] = args;
  if (typeof args[1] === 'function') {
    [eventType, listener, capture] = args;
    targetSelector = undefined;
  }
  if (!capture) capture = false;

  function handleLiveEvent(e) {
    const target = e.target;
    if (!target) return;
    const eventData = e.target.dom7EventData || [];
    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }
    if ($(target).is(targetSelector)) listener.apply(target, eventData);
    else {
      const parents = $(target).parents(); // eslint-disable-line
      for (let k = 0; k < parents.length; k += 1) {
        if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
      }
    }
  }
  function handleEvent(e) {
    const eventData = e && e.target ? e.target.dom7EventData || [] : [];
    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }
    listener.apply(this, eventData);
  }
  const events = eventType.split(' ');
  let j;
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (!targetSelector) {
      for (j = 0; j < events.length; j += 1) {
        const event = events[j];
        if (!el.dom7Listeners) el.dom7Listeners = {};
        if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
        el.dom7Listeners[event].push({
          listener,
          proxyListener: handleEvent,
        });
        el.addEventListener(event, handleEvent, capture);
      }
    } else {
      // Live events
      for (j = 0; j < events.length; j += 1) {
        const event = events[j];
        if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
        if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
        el.dom7LiveListeners[event].push({
          listener,
          proxyListener: handleLiveEvent,
        });
        el.addEventListener(event, handleLiveEvent, capture);
      }
    }
  }
  return this;
}
function off(...args) {
  let [eventType, targetSelector, listener, capture] = args;
  if (typeof args[1] === 'function') {
    [eventType, listener, capture] = args;
    targetSelector = undefined;
  }
  if (!capture) capture = false;

  const events = eventType.split(' ');
  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];
    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];
      let handlers;
      if (!targetSelector && el.dom7Listeners) {
        handlers = el.dom7Listeners[event];
      } else if (targetSelector && el.dom7LiveListeners) {
        handlers = el.dom7LiveListeners[event];
      }
      if (handlers && handlers.length) {
        for (let k = handlers.length - 1; k >= 0; k -= 1) {
          const handler = handlers[k];
          if (listener && handler.listener === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (!listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          }
        }
      }
    }
  }
  return this;
}
function once(...args) {
  const dom = this;
  let [eventName, targetSelector, listener, capture] = args;
  if (typeof args[1] === 'function') {
    [eventName, listener, capture] = args;
    targetSelector = undefined;
  }
  function onceHandler(...eventArgs) {
    listener.apply(this, eventArgs);
    dom.off(eventName, targetSelector, onceHandler, capture);
    if (onceHandler.dom7proxy) {
      delete onceHandler.dom7proxy;
    }
  }
  onceHandler.dom7proxy = listener;
  return dom.on(eventName, targetSelector, onceHandler, capture);
}
function trigger(...args) {
  const events = args[0].split(' ');
  const eventData = args[1];
  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];
    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];
      let evt;
      try {
        evt = new win.CustomEvent(event, {
          detail: eventData,
          bubbles: true,
          cancelable: true,
        });
      } catch (e) {
        evt = doc.createEvent('Event');
        evt.initEvent(event, true, true);
        evt.detail = eventData;
      }
      // eslint-disable-next-line
      el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
      el.dispatchEvent(evt);
      el.dom7EventData = [];
      delete el.dom7EventData;
    }
  }
  return this;
}
function transitionEnd(callback) {
  const events = ['webkitTransitionEnd', 'transitionend'];
  const dom = this;
  let i;
  function fireCallBack(e) {
    /* jshint validthis:true */
    if (e.target !== this) return;
    callback.call(this, e);
    for (i = 0; i < events.length; i += 1) {
      dom.off(events[i], fireCallBack);
    }
  }
  if (callback) {
    for (i = 0; i < events.length; i += 1) {
      dom.on(events[i], fireCallBack);
    }
  }
  return this;
}
function animationEnd(callback) {
  const events = ['webkitAnimationEnd', 'animationend'];
  const dom = this;
  let i;
  function fireCallBack(e) {
    if (e.target !== this) return;
    callback.call(this, e);
    for (i = 0; i < events.length; i += 1) {
      dom.off(events[i], fireCallBack);
    }
  }
  if (callback) {
    for (i = 0; i < events.length; i += 1) {
      dom.on(events[i], fireCallBack);
    }
  }
  return this;
}
// Sizing/Styles
function width() {
  if (this[0] === win) {
    return win.innerWidth;
  }

  if (this.length > 0) {
    return parseFloat(this.css('width'));
  }

  return null;
}
function dom7_modular_outerWidth(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      // eslint-disable-next-line
      const styles = this.styles();
      return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
    }
    return this[0].offsetWidth;
  }
  return null;
}
function height() {
  if (this[0] === win) {
    return win.innerHeight;
  }

  if (this.length > 0) {
    return parseFloat(this.css('height'));
  }

  return null;
}
function dom7_modular_outerHeight(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      // eslint-disable-next-line
      const styles = this.styles();
      return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
    }
    return this[0].offsetHeight;
  }
  return null;
}
function dom7_modular_offset() {
  if (this.length > 0) {
    const el = this[0];
    const box = el.getBoundingClientRect();
    const body = doc.body;
    const clientTop = el.clientTop || body.clientTop || 0;
    const clientLeft = el.clientLeft || body.clientLeft || 0;
    const scrollTop = el === win ? win.scrollY : el.scrollTop;
    const scrollLeft = el === win ? win.scrollX : el.scrollLeft;
    return {
      top: (box.top + scrollTop) - clientTop,
      left: (box.left + scrollLeft) - clientLeft,
    };
  }

  return null;
}
function hide() {
  for (let i = 0; i < this.length; i += 1) {
    this[i].style.display = 'none';
  }
  return this;
}
function show() {
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (el.style.display === 'none') {
      el.style.display = '';
    }
    if (win.getComputedStyle(el, null).getPropertyValue('display') === 'none') {
      // Still not visible
      el.style.display = 'block';
    }
  }
  return this;
}
function styles() {
  if (this[0]) return win.getComputedStyle(this[0], null);
  return {};
}
function css(props, value) {
  let i;
  if (arguments.length === 1) {
    if (typeof props === 'string') {
      if (this[0]) return win.getComputedStyle(this[0], null).getPropertyValue(props);
    } else {
      for (i = 0; i < this.length; i += 1) {
        // eslint-disable-next-line
        for (let prop in props) {
          this[i].style[prop] = props[prop];
        }
      }
      return this;
    }
  }
  if (arguments.length === 2 && typeof props === 'string') {
    for (i = 0; i < this.length; i += 1) {
      this[i].style[props] = value;
    }
    return this;
  }
  return this;
}

// Dom manipulation
function toArray() {
  const arr = [];
  for (let i = 0; i < this.length; i += 1) {
    arr.push(this[i]);
  }
  return arr;
}
// Iterate over the collection passing elements to `callback`
function each(callback) {
  // Don't bother continuing without a callback
  if (!callback) return this;
  // Iterate over the current collection
  for (let i = 0; i < this.length; i += 1) {
    // If the callback returns false
    if (callback.call(this[i], i, this[i]) === false) {
      // End the loop early
      return this;
    }
  }
  // Return `this` to allow chained DOM operations
  return this;
}
function forEach(callback) {
  // Don't bother continuing without a callback
  if (!callback) return this;
  // Iterate over the current collection
  for (let i = 0; i < this.length; i += 1) {
    // If the callback returns false
    if (callback.call(this[i], this[i], i) === false) {
      // End the loop early
      return this;
    }
  }
  // Return `this` to allow chained DOM operations
  return this;
}
function filter(callback) {
  const matchedItems = [];
  const dom = this;
  for (let i = 0; i < dom.length; i += 1) {
    if (callback.call(dom[i], i, dom[i])) matchedItems.push(dom[i]);
  }
  return new Dom7(matchedItems);
}
function map(callback) {
  const modifiedItems = [];
  const dom = this;
  for (let i = 0; i < dom.length; i += 1) {
    modifiedItems.push(callback.call(dom[i], i, dom[i]));
  }
  return new Dom7(modifiedItems);
}
// eslint-disable-next-line
function dom7_modular_html(html) {
  if (typeof html === 'undefined') {
    return this[0] ? this[0].innerHTML : undefined;
  }

  for (let i = 0; i < this.length; i += 1) {
    this[i].innerHTML = html;
  }
  return this;
}
// eslint-disable-next-line
function dom7_modular_text(text) {
  if (typeof text === 'undefined') {
    if (this[0]) {
      return this[0].textContent.trim();
    }
    return null;
  }

  for (let i = 0; i < this.length; i += 1) {
    this[i].textContent = text;
  }
  return this;
}
function is(selector) {
  const el = this[0];
  let compareWith;
  let i;
  if (!el || typeof selector === 'undefined') return false;
  if (typeof selector === 'string') {
    if (el.matches) return el.matches(selector);
    else if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
    else if (el.msMatchesSelector) return el.msMatchesSelector(selector);

    compareWith = $(selector);
    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }
    return false;
  } else if (selector === doc) return el === doc;
  else if (selector === win) return el === win;

  if (selector.nodeType || selector instanceof Dom7) {
    compareWith = selector.nodeType ? [selector] : selector;
    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }
    return false;
  }
  return false;
}
function indexOf(el) {
  for (let i = 0; i < this.length; i += 1) {
    if (this[i] === el) return i;
  }
  return -1;
}
function dom7_modular_index() {
  let child = this[0];
  let i;
  if (child) {
    i = 0;
    // eslint-disable-next-line
    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i += 1;
    }
    return i;
  }
  return undefined;
}
// eslint-disable-next-line
function eq(index) {
  if (typeof index === 'undefined') return this;
  const length = this.length;
  let returnIndex;
  if (index > length - 1) {
    return new Dom7([]);
  }
  if (index < 0) {
    returnIndex = length + index;
    if (returnIndex < 0) return new Dom7([]);
    return new Dom7([this[returnIndex]]);
  }
  return new Dom7([this[index]]);
}
function append(...args) {
  let newChild;

  for (let k = 0; k < args.length; k += 1) {
    newChild = args[k];
    for (let i = 0; i < this.length; i += 1) {
      if (typeof newChild === 'string') {
        const tempDiv = doc.createElement('div');
        tempDiv.innerHTML = newChild;
        while (tempDiv.firstChild) {
          this[i].appendChild(tempDiv.firstChild);
        }
      } else if (newChild instanceof Dom7) {
        for (let j = 0; j < newChild.length; j += 1) {
          this[i].appendChild(newChild[j]);
        }
      } else {
        this[i].appendChild(newChild);
      }
    }
  }

  return this;
}
// eslint-disable-next-line
function appendTo(parent) {
  $(parent).append(this);
  return this;
}
function prepend(newChild) {
  let i;
  let j;
  for (i = 0; i < this.length; i += 1) {
    if (typeof newChild === 'string') {
      const tempDiv = doc.createElement('div');
      tempDiv.innerHTML = newChild;
      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
      }
    } else if (newChild instanceof Dom7) {
      for (j = 0; j < newChild.length; j += 1) {
        this[i].insertBefore(newChild[j], this[i].childNodes[0]);
      }
    } else {
      this[i].insertBefore(newChild, this[i].childNodes[0]);
    }
  }
  return this;
}
// eslint-disable-next-line
function prependTo(parent) {
  $(parent).prepend(this);
  return this;
}
function insertBefore(selector) {
  const before = $(selector);
  for (let i = 0; i < this.length; i += 1) {
    if (before.length === 1) {
      before[0].parentNode.insertBefore(this[i], before[0]);
    } else if (before.length > 1) {
      for (let j = 0; j < before.length; j += 1) {
        before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
      }
    }
  }
}
function insertAfter(selector) {
  const after = $(selector);
  for (let i = 0; i < this.length; i += 1) {
    if (after.length === 1) {
      after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
    } else if (after.length > 1) {
      for (let j = 0; j < after.length; j += 1) {
        after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
      }
    }
  }
}
function next(selector) {
  if (this.length > 0) {
    if (selector) {
      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
        return new Dom7([this[0].nextElementSibling]);
      }
      return new Dom7([]);
    }

    if (this[0].nextElementSibling) return new Dom7([this[0].nextElementSibling]);
    return new Dom7([]);
  }
  return new Dom7([]);
}
function nextAll(selector) {
  const nextEls = [];
  let el = this[0];
  if (!el) return new Dom7([]);
  while (el.nextElementSibling) {
    const next = el.nextElementSibling; // eslint-disable-line
    if (selector) {
      if ($(next).is(selector)) nextEls.push(next);
    } else nextEls.push(next);
    el = next;
  }
  return new Dom7(nextEls);
}
function prev(selector) {
  if (this.length > 0) {
    const el = this[0];
    if (selector) {
      if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
        return new Dom7([el.previousElementSibling]);
      }
      return new Dom7([]);
    }

    if (el.previousElementSibling) return new Dom7([el.previousElementSibling]);
    return new Dom7([]);
  }
  return new Dom7([]);
}
function prevAll(selector) {
  const prevEls = [];
  let el = this[0];
  if (!el) return new Dom7([]);
  while (el.previousElementSibling) {
    const prev = el.previousElementSibling; // eslint-disable-line
    if (selector) {
      if ($(prev).is(selector)) prevEls.push(prev);
    } else prevEls.push(prev);
    el = prev;
  }
  return new Dom7(prevEls);
}
function siblings(selector) {
  return this.nextAll(selector).add(this.prevAll(selector));
}
function dom7_modular_parent(selector) {
  const parents = []; // eslint-disable-line
  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode !== null) {
      if (selector) {
        if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
      } else {
        parents.push(this[i].parentNode);
      }
    }
  }
  return $(unique(parents));
}
function parents(selector) {
  const parents = []; // eslint-disable-line
  for (let i = 0; i < this.length; i += 1) {
    let parent = this[i].parentNode; // eslint-disable-line
    while (parent) {
      if (selector) {
        if ($(parent).is(selector)) parents.push(parent);
      } else {
        parents.push(parent);
      }
      parent = parent.parentNode;
    }
  }
  return $(unique(parents));
}
function closest(selector) {
  let closest = this; // eslint-disable-line
  if (typeof selector === 'undefined') {
    return new Dom7([]);
  }
  if (!closest.is(selector)) {
    closest = closest.parents(selector).eq(0);
  }
  return closest;
}
function find(selector) {
  const foundElements = [];
  for (let i = 0; i < this.length; i += 1) {
    const found = this[i].querySelectorAll(selector);
    for (let j = 0; j < found.length; j += 1) {
      foundElements.push(found[j]);
    }
  }
  return new Dom7(foundElements);
}
function children(selector) {
  const children = []; // eslint-disable-line
  for (let i = 0; i < this.length; i += 1) {
    const childNodes = this[i].childNodes;

    for (let j = 0; j < childNodes.length; j += 1) {
      if (!selector) {
        if (childNodes[j].nodeType === 1) children.push(childNodes[j]);
      } else if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
        children.push(childNodes[j]);
      }
    }
  }
  return new Dom7(unique(children));
}
function remove() {
  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
  }
  return this;
}
function detach() {
  return this.remove();
}
function add(...args) {
  const dom = this;
  let i;
  let j;
  for (i = 0; i < args.length; i += 1) {
    const toAdd = $(args[i]);
    for (j = 0; j < toAdd.length; j += 1) {
      dom[dom.length] = toAdd[j];
      dom.length += 1;
    }
  }
  return dom;
}
function empty() {
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (el.nodeType === 1) {
      for (let j = 0; j < el.childNodes.length; j += 1) {
        if (el.childNodes[j].parentNode) {
          el.childNodes[j].parentNode.removeChild(el.childNodes[j]);
        }
      }
      el.textContent = '';
    }
  }
  return this;
}

function scrollTo(...args) {
  let [left, top, duration, easing, callback] = args;
  if (args.length === 4 && typeof easing === 'function') {
    callback = easing;
    [left, top, duration, callback, easing] = args;
  }
  if (typeof easing === 'undefined') easing = 'swing';

  return this.each(function animate() {
    const el = this;
    let currentTop;
    let currentLeft;
    let maxTop;
    let maxLeft;
    let newTop;
    let newLeft;
    let scrollTop; // eslint-disable-line
    let scrollLeft; // eslint-disable-line
    let animateTop = top > 0 || top === 0;
    let animateLeft = left > 0 || left === 0;
    if (typeof easing === 'undefined') {
      easing = 'swing';
    }
    if (animateTop) {
      currentTop = el.scrollTop;
      if (!duration) {
        el.scrollTop = top;
      }
    }
    if (animateLeft) {
      currentLeft = el.scrollLeft;
      if (!duration) {
        el.scrollLeft = left;
      }
    }
    if (!duration) return;
    if (animateTop) {
      maxTop = el.scrollHeight - el.offsetHeight;
      newTop = Math.max(Math.min(top, maxTop), 0);
    }
    if (animateLeft) {
      maxLeft = el.scrollWidth - el.offsetWidth;
      newLeft = Math.max(Math.min(left, maxLeft), 0);
    }
    let startTime = null;
    if (animateTop && newTop === currentTop) animateTop = false;
    if (animateLeft && newLeft === currentLeft) animateLeft = false;
    function render(time = new Date().getTime()) {
      if (startTime === null) {
        startTime = time;
      }
      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
      const easeProgress = easing === 'linear' ? progress : (0.5 - (Math.cos(progress * Math.PI) / 2));
      let done;
      if (animateTop) scrollTop = currentTop + (easeProgress * (newTop - currentTop));
      if (animateLeft) scrollLeft = currentLeft + (easeProgress * (newLeft - currentLeft));
      if (animateTop && newTop > currentTop && scrollTop >= newTop) {
        el.scrollTop = newTop;
        done = true;
      }
      if (animateTop && newTop < currentTop && scrollTop <= newTop) {
        el.scrollTop = newTop;
        done = true;
      }
      if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }
      if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }

      if (done) {
        if (callback) callback();
        return;
      }
      if (animateTop) el.scrollTop = scrollTop;
      if (animateLeft) el.scrollLeft = scrollLeft;
      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
  });
}
// scrollTop(top, duration, easing, callback) {
function dom7_modular_scrollTop(...args) {
  let [top, duration, easing, callback] = args;
  if (args.length === 3 && typeof easing === 'function') {
    [top, duration, callback, easing] = args;
  }
  const dom = this;
  if (typeof top === 'undefined') {
    if (dom.length > 0) return dom[0].scrollTop;
    return null;
  }
  return dom.scrollTo(undefined, top, duration, easing, callback);
}
function dom7_modular_scrollLeft(...args) {
  let [left, duration, easing, callback] = args;
  if (args.length === 3 && typeof easing === 'function') {
    [left, duration, callback, easing] = args;
  }
  const dom = this;
  if (typeof left === 'undefined') {
    if (dom.length > 0) return dom[0].scrollLeft;
    return null;
  }
  return dom.scrollTo(left, undefined, duration, easing, callback);
}

function animate(initialProps, initialParams) {
  const els = this;
  const a = {
    props: Object.assign({}, initialProps),
    params: Object.assign({
      duration: 300,
      easing: 'swing', // or 'linear'
      /* Callbacks
      begin(elements)
      complete(elements)
      progress(elements, complete, remaining, start, tweenValue)
      */
    }, initialParams),

    elements: els,
    animating: false,
    que: [],

    easingProgress(easing, progress) {
      if (easing === 'swing') {
        return 0.5 - (Math.cos(progress * Math.PI) / 2);
      }
      if (typeof easing === 'function') {
        return easing(progress);
      }
      return progress;
    },
    stop() {
      if (a.frameId) {
        cancelAnimationFrame(a.frameId);
      }
      a.animating = false;
      a.elements.each((index, el) => {
        const element = el;
        delete element.dom7AnimateInstance;
      });
      a.que = [];
    },
    done(complete) {
      a.animating = false;
      a.elements.each((index, el) => {
        const element = el;
        delete element.dom7AnimateInstance;
      });
      if (complete) complete(els);
      if (a.que.length > 0) {
        const que = a.que.shift();
        a.animate(que[0], que[1]);
      }
    },
    animate(props, params) {
      if (a.animating) {
        a.que.push([props, params]);
        return a;
      }
      const elements = [];

      // Define & Cache Initials & Units
      a.elements.each((index, el) => {
        let initialFullValue;
        let initialValue;
        let unit;
        let finalValue;
        let finalFullValue;

        if (!el.dom7AnimateInstance) a.elements[index].dom7AnimateInstance = a;

        elements[index] = {
          container: el,
        };
        Object.keys(props).forEach((prop) => {
          initialFullValue = win.getComputedStyle(el, null).getPropertyValue(prop).replace(',', '.');
          initialValue = parseFloat(initialFullValue);
          unit = initialFullValue.replace(initialValue, '');
          finalValue = parseFloat(props[prop]);
          finalFullValue = props[prop] + unit;
          elements[index][prop] = {
            initialFullValue,
            initialValue,
            unit,
            finalValue,
            finalFullValue,
            currentValue: initialValue,
          };
        });
      });

      let startTime = null;
      let time;
      let elementsDone = 0;
      let propsDone = 0;
      let done;
      let began = false;

      a.animating = true;

      function render() {
        time = new Date().getTime();
        let progress;
        let easeProgress;
        // let el;
        if (!began) {
          began = true;
          if (params.begin) params.begin(els);
        }
        if (startTime === null) {
          startTime = time;
        }
        if (params.progress) {
          // eslint-disable-next-line
          params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), ((startTime + params.duration) - time < 0 ? 0 : (startTime + params.duration) - time), startTime);
        }

        elements.forEach((element) => {
          const el = element;
          if (done || el.done) return;
          Object.keys(props).forEach((prop) => {
            if (done || el.done) return;
            progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);
            easeProgress = a.easingProgress(params.easing, progress);
            const { initialValue, finalValue, unit } = el[prop];
            el[prop].currentValue = initialValue + (easeProgress * (finalValue - initialValue));
            const currentValue = el[prop].currentValue;

            if (
              (finalValue > initialValue && currentValue >= finalValue) ||
              (finalValue < initialValue && currentValue <= finalValue)) {
              el.container.style[prop] = finalValue + unit;
              propsDone += 1;
              if (propsDone === Object.keys(props).length) {
                el.done = true;
                elementsDone += 1;
              }
              if (elementsDone === elements.length) {
                done = true;
              }
            }
            if (done) {
              a.done(params.complete);
              return;
            }
            el.container.style[prop] = currentValue + unit;
          });
        });
        if (done) return;
        // Then call
        a.frameId = requestAnimationFrame(render);
      }
      a.frameId = requestAnimationFrame(render);
      return a;
    },
  };

  if (a.elements.length === 0) {
    return els;
  }

  let animateInstance;
  for (let i = 0; i < a.elements.length; i += 1) {
    if (a.elements[i].dom7AnimateInstance) {
      animateInstance = a.elements[i].dom7AnimateInstance;
    } else a.elements[i].dom7AnimateInstance = a;
  }
  if (!animateInstance) {
    animateInstance = a;
  }

  if (initialProps === 'stop') {
    animateInstance.stop();
  } else {
    animateInstance.animate(a.props, a.params);
  }

  return els;
}

function stop() {
  const els = this;
  for (let i = 0; i < els.length; i += 1) {
    if (els[i].dom7AnimateInstance) {
      els[i].dom7AnimateInstance.stop();
    }
  }
}

const noTrigger = ('resize scroll').split(' ');
function eventShortcut(name, ...args) {
  if (typeof args[0] === 'undefined') {
    for (let i = 0; i < this.length; i += 1) {
      if (noTrigger.indexOf(name) < 0) {
        if (name in this[i]) this[i][name]();
        else {
          $(this[i]).trigger(name);
        }
      }
    }
    return this;
  }
  return this.on(name, ...args);
}

function click(...args) {
  return eventShortcut.bind(this)('click', ...args);
}
function dom7_modular_blur(...args) {
  return eventShortcut.bind(this)('blur', ...args);
}
function dom7_modular_focus(...args) {
  return eventShortcut.bind(this)('focus', ...args);
}
function focusin(...args) {
  return eventShortcut.bind(this)('focusin', ...args);
}
function focusout(...args) {
  return eventShortcut.bind(this)('focusout', ...args);
}
function keyup(...args) {
  return eventShortcut.bind(this)('keyup', ...args);
}
function keydown(...args) {
  return eventShortcut.bind(this)('keydown', ...args);
}
function keypress(...args) {
  return eventShortcut.bind(this)('keypress', ...args);
}
function dom7_modular_submit(...args) {
  return eventShortcut.bind(this)('submit', ...args);
}
function change(...args) {
  return eventShortcut.bind(this)('change', ...args);
}
function mousedown(...args) {
  return eventShortcut.bind(this)('mousedown', ...args);
}
function mousemove(...args) {
  return eventShortcut.bind(this)('mousemove', ...args);
}
function mouseup(...args) {
  return eventShortcut.bind(this)('mouseup', ...args);
}
function mouseenter(...args) {
  return eventShortcut.bind(this)('mouseenter', ...args);
}
function mouseleave(...args) {
  return eventShortcut.bind(this)('mouseleave', ...args);
}
function mouseout(...args) {
  return eventShortcut.bind(this)('mouseout', ...args);
}
function mouseover(...args) {
  return eventShortcut.bind(this)('mouseover', ...args);
}
function touchstart(...args) {
  return eventShortcut.bind(this)('touchstart', ...args);
}
function touchend(...args) {
  return eventShortcut.bind(this)('touchend', ...args);
}
function touchmove(...args) {
  return eventShortcut.bind(this)('touchmove', ...args);
}
function resize(...args) {
  return eventShortcut.bind(this)('resize', ...args);
}
function dom7_modular_scroll(...args) {
  return eventShortcut.bind(this)('scroll', ...args);
}



// CONCATENATED MODULE: ./node_modules/ssr-window/dist/ssr-window.esm.js
/**
 * SSR Window 1.0.1
 * Better handling for window object in SSR environment
 * https://github.com/nolimits4web/ssr-window
 *
 * Copyright 2018, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: July 18, 2018
 */
var ssr_window_esm_doc = (typeof document === 'undefined') ? {
  body: {},
  addEventListener: function addEventListener() {},
  removeEventListener: function removeEventListener() {},
  activeElement: {
    blur: function blur() {},
    nodeName: '',
  },
  querySelector: function querySelector() {
    return null;
  },
  querySelectorAll: function querySelectorAll() {
    return [];
  },
  getElementById: function getElementById() {
    return null;
  },
  createEvent: function createEvent() {
    return {
      initEvent: function initEvent() {},
    };
  },
  createElement: function createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute: function setAttribute() {},
      getElementsByTagName: function getElementsByTagName() {
        return [];
      },
    };
  },
  location: { hash: '' },
} : document; // eslint-disable-line

var ssr_window_esm_win = (typeof window === 'undefined') ? {
  document: ssr_window_esm_doc,
  navigator: {
    userAgent: '',
  },
  location: {},
  history: {},
  CustomEvent: function CustomEvent() {
    return this;
  },
  addEventListener: function addEventListener() {},
  removeEventListener: function removeEventListener() {},
  getComputedStyle: function getComputedStyle() {
    return {
      getPropertyValue: function getPropertyValue() {
        return '';
      },
    };
  },
  Image: function Image() {},
  Date: function Date() {},
  screen: {},
  setTimeout: function setTimeout() {},
  clearTimeout: function clearTimeout() {},
} : window; // eslint-disable-line



// CONCATENATED MODULE: ./node_modules/swiper/dist/js/swiper.esm.bundle.js
/**
 * Swiper 4.5.1
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * http://www.idangero.us/swiper/
 *
 * Copyright 2014-2019 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: September 13, 2019
 */




const Methods = {
  addClass: addClass,
  removeClass: removeClass,
  hasClass: hasClass,
  toggleClass: toggleClass,
  attr: attr,
  removeAttr: removeAttr,
  data: dom7_modular_data,
  transform: dom7_modular_transform,
  transition: transition,
  on: on,
  off: off,
  trigger: trigger,
  transitionEnd: transitionEnd,
  outerWidth: dom7_modular_outerWidth,
  outerHeight: dom7_modular_outerHeight,
  offset: dom7_modular_offset,
  css: css,
  each: each,
  html: dom7_modular_html,
  text: dom7_modular_text,
  is: is,
  index: dom7_modular_index,
  eq: eq,
  append: append,
  prepend: prepend,
  next: next,
  nextAll: nextAll,
  prev: prev,
  prevAll: prevAll,
  parent: dom7_modular_parent,
  parents: parents,
  closest: closest,
  find: find,
  children: children,
  remove: remove,
  add: add,
  styles: styles,
};

Object.keys(Methods).forEach((methodName) => {
  $.fn[methodName] = $.fn[methodName] || Methods[methodName];
});

const Utils = {
  deleteProps(obj) {
    const object = obj;
    Object.keys(object).forEach((key) => {
      try {
        object[key] = null;
      } catch (e) {
        // no getter for object
      }
      try {
        delete object[key];
      } catch (e) {
        // something got wrong
      }
    });
  },
  nextTick(callback, delay = 0) {
    return setTimeout(callback, delay);
  },
  now() {
    return Date.now();
  },
  getTranslate(el, axis = 'x') {
    let matrix;
    let curTransform;
    let transformMatrix;

    const curStyle = ssr_window_esm_win.getComputedStyle(el, null);

    if (ssr_window_esm_win.WebKitCSSMatrix) {
      curTransform = curStyle.transform || curStyle.webkitTransform;
      if (curTransform.split(',').length > 6) {
        curTransform = curTransform.split(', ').map((a) => a.replace(',', '.')).join(', ');
      }
      // Some old versions of Webkit choke when 'none' is passed; pass
      // empty string instead in this case
      transformMatrix = new ssr_window_esm_win.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
    } else {
      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
      matrix = transformMatrix.toString().split(',');
    }

    if (axis === 'x') {
      // Latest Chrome and webkits Fix
      if (ssr_window_esm_win.WebKitCSSMatrix) curTransform = transformMatrix.m41;
      // Crazy IE10 Matrix
      else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
      // Normal Browsers
      else curTransform = parseFloat(matrix[4]);
    }
    if (axis === 'y') {
      // Latest Chrome and webkits Fix
      if (ssr_window_esm_win.WebKitCSSMatrix) curTransform = transformMatrix.m42;
      // Crazy IE10 Matrix
      else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
      // Normal Browsers
      else curTransform = parseFloat(matrix[5]);
    }
    return curTransform || 0;
  },
  parseUrlQuery(url) {
    const query = {};
    let urlToParse = url || ssr_window_esm_win.location.href;
    let i;
    let params;
    let param;
    let length;
    if (typeof urlToParse === 'string' && urlToParse.length) {
      urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';
      params = urlToParse.split('&').filter((paramsPart) => paramsPart !== '');
      length = params.length;

      for (i = 0; i < length; i += 1) {
        param = params[i].replace(/#\S+/g, '').split('=');
        query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param[1]) || '';
      }
    }
    return query;
  },
  isObject(o) {
    return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
  },
  extend(...args) {
    const to = Object(args[0]);
    for (let i = 1; i < args.length; i += 1) {
      const nextSource = args[i];
      if (nextSource !== undefined && nextSource !== null) {
        const keysArray = Object.keys(Object(nextSource));
        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
          const nextKey = keysArray[nextIndex];
          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
              Utils.extend(to[nextKey], nextSource[nextKey]);
            } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
              to[nextKey] = {};
              Utils.extend(to[nextKey], nextSource[nextKey]);
            } else {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
    }
    return to;
  },
};

const swiper_esm_bundle_Support = (function Support() {
  const testDiv = ssr_window_esm_doc.createElement('div');
  return {
    touch: (ssr_window_esm_win.Modernizr && ssr_window_esm_win.Modernizr.touch === true) || (function checkTouch() {
      return !!((ssr_window_esm_win.navigator.maxTouchPoints > 0) || ('ontouchstart' in ssr_window_esm_win) || (ssr_window_esm_win.DocumentTouch && ssr_window_esm_doc instanceof ssr_window_esm_win.DocumentTouch));
    }()),

    pointerEvents: !!(ssr_window_esm_win.navigator.pointerEnabled || ssr_window_esm_win.PointerEvent || ('maxTouchPoints' in ssr_window_esm_win.navigator && ssr_window_esm_win.navigator.maxTouchPoints > 0)),
    prefixedPointerEvents: !!ssr_window_esm_win.navigator.msPointerEnabled,

    transition: (function checkTransition() {
      const style = testDiv.style;
      return ('transition' in style || 'webkitTransition' in style || 'MozTransition' in style);
    }()),
    transforms3d: (ssr_window_esm_win.Modernizr && ssr_window_esm_win.Modernizr.csstransforms3d === true) || (function checkTransforms3d() {
      const style = testDiv.style;
      return ('webkitPerspective' in style || 'MozPerspective' in style || 'OPerspective' in style || 'MsPerspective' in style || 'perspective' in style);
    }()),

    flexbox: (function checkFlexbox() {
      const style = testDiv.style;
      const styles = ('alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient').split(' ');
      for (let i = 0; i < styles.length; i += 1) {
        if (styles[i] in style) return true;
      }
      return false;
    }()),

    observer: (function checkObserver() {
      return ('MutationObserver' in ssr_window_esm_win || 'WebkitMutationObserver' in ssr_window_esm_win);
    }()),

    passiveListener: (function checkPassiveListener() {
      let supportsPassive = false;
      try {
        const opts = Object.defineProperty({}, 'passive', {
          // eslint-disable-next-line
          get() {
            supportsPassive = true;
          },
        });
        ssr_window_esm_win.addEventListener('testPassiveListener', null, opts);
      } catch (e) {
        // No support
      }
      return supportsPassive;
    }()),

    gestures: (function checkGestures() {
      return 'ongesturestart' in ssr_window_esm_win;
    }()),
  };
}());

const swiper_esm_bundle_Browser = (function Browser() {
  function isSafari() {
    const ua = ssr_window_esm_win.navigator.userAgent.toLowerCase();
    return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);
  }
  return {
    isIE: !!ssr_window_esm_win.navigator.userAgent.match(/Trident/g) || !!ssr_window_esm_win.navigator.userAgent.match(/MSIE/g),
    isEdge: !!ssr_window_esm_win.navigator.userAgent.match(/Edge/g),
    isSafari: isSafari(),
    isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(ssr_window_esm_win.navigator.userAgent),
  };
}());

class SwiperClass {
  constructor(params = {}) {
    const self = this;
    self.params = params;

    // Events
    self.eventsListeners = {};

    if (self.params && self.params.on) {
      Object.keys(self.params.on).forEach((eventName) => {
        self.on(eventName, self.params.on[eventName]);
      });
    }
  }

  on(events, handler, priority) {
    const self = this;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';
    events.split(' ').forEach((event) => {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event][method](handler);
    });
    return self;
  }

  once(events, handler, priority) {
    const self = this;
    if (typeof handler !== 'function') return self;
    function onceHandler(...args) {
      handler.apply(self, args);
      self.off(events, onceHandler);
      if (onceHandler.f7proxy) {
        delete onceHandler.f7proxy;
      }
    }
    onceHandler.f7proxy = handler;
    return self.on(events, onceHandler, priority);
  }

  off(events, handler) {
    const self = this;
    if (!self.eventsListeners) return self;
    events.split(' ').forEach((event) => {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event] && self.eventsListeners[event].length) {
        self.eventsListeners[event].forEach((eventHandler, index) => {
          if (eventHandler === handler || (eventHandler.f7proxy && eventHandler.f7proxy === handler)) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  }

  emit(...args) {
    const self = this;
    if (!self.eventsListeners) return self;
    let events;
    let data;
    let context;
    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data = args.slice(1, args.length);
      context = self;
    } else {
      events = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
    }
    const eventsArray = Array.isArray(events) ? events : events.split(' ');
    eventsArray.forEach((event) => {
      if (self.eventsListeners && self.eventsListeners[event]) {
        const handlers = [];
        self.eventsListeners[event].forEach((eventHandler) => {
          handlers.push(eventHandler);
        });
        handlers.forEach((eventHandler) => {
          eventHandler.apply(context, data);
        });
      }
    });
    return self;
  }

  useModulesParams(instanceParams) {
    const instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach((moduleName) => {
      const module = instance.modules[moduleName];
      // Extend params
      if (module.params) {
        Utils.extend(instanceParams, module.params);
      }
    });
  }

  useModules(modulesParams = {}) {
    const instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach((moduleName) => {
      const module = instance.modules[moduleName];
      const moduleParams = modulesParams[moduleName] || {};
      // Extend instance methods and props
      if (module.instance) {
        Object.keys(module.instance).forEach((modulePropName) => {
          const moduleProp = module.instance[modulePropName];
          if (typeof moduleProp === 'function') {
            instance[modulePropName] = moduleProp.bind(instance);
          } else {
            instance[modulePropName] = moduleProp;
          }
        });
      }
      // Add event listeners
      if (module.on && instance.on) {
        Object.keys(module.on).forEach((moduleEventName) => {
          instance.on(moduleEventName, module.on[moduleEventName]);
        });
      }

      // Module create callback
      if (module.create) {
        module.create.bind(instance)(moduleParams);
      }
    });
  }

  static set components(components) {
    const Class = this;
    if (!Class.use) return;
    Class.use(components);
  }

  static installModule(module, ...params) {
    const Class = this;
    if (!Class.prototype.modules) Class.prototype.modules = {};
    const name = module.name || (`${Object.keys(Class.prototype.modules).length}_${Utils.now()}`);
    Class.prototype.modules[name] = module;
    // Prototype
    if (module.proto) {
      Object.keys(module.proto).forEach((key) => {
        Class.prototype[key] = module.proto[key];
      });
    }
    // Class
    if (module.static) {
      Object.keys(module.static).forEach((key) => {
        Class[key] = module.static[key];
      });
    }
    // Callback
    if (module.install) {
      module.install.apply(Class, params);
    }
    return Class;
  }

  static use(module, ...params) {
    const Class = this;
    if (Array.isArray(module)) {
      module.forEach((m) => Class.installModule(m));
      return Class;
    }
    return Class.installModule(module, ...params);
  }
}

function updateSize () {
  const swiper = this;
  let width;
  let height;
  const $el = swiper.$el;
  if (typeof swiper.params.width !== 'undefined') {
    width = swiper.params.width;
  } else {
    width = $el[0].clientWidth;
  }
  if (typeof swiper.params.height !== 'undefined') {
    height = swiper.params.height;
  } else {
    height = $el[0].clientHeight;
  }
  if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {
    return;
  }

  // Subtract paddings
  width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);
  height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);

  Utils.extend(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height,
  });
}

function updateSlides () {
  const swiper = this;
  const params = swiper.params;

  const {
    $wrapperEl, size: swiperSize, rtlTranslate: rtl, wrongRTL,
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];

  let offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === 'function') {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }

  let offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === 'function') {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }

  const previousSnapGridLength = swiper.snapGrid.length;
  const previousSlidesGridLength = swiper.snapGrid.length;

  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index = 0;
  if (typeof swiperSize === 'undefined') {
    return;
  }
  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;
  }

  swiper.virtualSize = -spaceBetween;

  // reset margins
  if (rtl) slides.css({ marginLeft: '', marginTop: '' });
  else slides.css({ marginRight: '', marginBottom: '' });

  let slidesNumberEvenToRows;
  if (params.slidesPerColumn > 1) {
    if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
      slidesNumberEvenToRows = slidesLength;
    } else {
      slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
    }
    if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
    }
  }

  // Calc slides
  let slideSize;
  const slidesPerColumn = params.slidesPerColumn;
  const slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
  const numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);
  for (let i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    const slide = slides.eq(i);
    if (params.slidesPerColumn > 1) {
      // Set slides order
      let newSlideOrderIndex;
      let column;
      let row;
      if (
        (params.slidesPerColumnFill === 'column')
        || (params.slidesPerColumnFill === 'row' && params.slidesPerGroup > 1)
      ) {
        if (params.slidesPerColumnFill === 'column') {
          column = Math.floor(i / slidesPerColumn);
          row = i - (column * slidesPerColumn);
          if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {
            row += 1;
            if (row >= slidesPerColumn) {
              row = 0;
              column += 1;
            }
          }
        } else {
          const groupIndex = Math.floor(i / params.slidesPerGroup);
          row = Math.floor(i / params.slidesPerView) - groupIndex * params.slidesPerColumn;
          column = i - row * params.slidesPerView - groupIndex * params.slidesPerView;
        }
        newSlideOrderIndex = column + ((row * slidesNumberEvenToRows) / slidesPerColumn);
        slide
          .css({
            '-webkit-box-ordinal-group': newSlideOrderIndex,
            '-moz-box-ordinal-group': newSlideOrderIndex,
            '-ms-flex-order': newSlideOrderIndex,
            '-webkit-order': newSlideOrderIndex,
            order: newSlideOrderIndex,
          });
      } else {
        row = Math.floor(i / slidesPerRow);
        column = i - (row * slidesPerRow);
      }
      slide
        .css(
          `margin-${swiper.isHorizontal() ? 'top' : 'left'}`,
          (row !== 0 && params.spaceBetween) && (`${params.spaceBetween}px`)
        )
        .attr('data-swiper-column', column)
        .attr('data-swiper-row', row);
    }
    if (slide.css('display') === 'none') continue; // eslint-disable-line

    if (params.slidesPerView === 'auto') {
      const slideStyles = ssr_window_esm_win.getComputedStyle(slide[0], null);
      const currentTransform = slide[0].style.transform;
      const currentWebKitTransform = slide[0].style.webkitTransform;
      if (currentTransform) {
        slide[0].style.transform = 'none';
      }
      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = 'none';
      }
      if (params.roundLengths) {
        slideSize = swiper.isHorizontal()
          ? slide.outerWidth(true)
          : slide.outerHeight(true);
      } else {
        // eslint-disable-next-line
        if (swiper.isHorizontal()) {
          const width = parseFloat(slideStyles.getPropertyValue('width'));
          const paddingLeft = parseFloat(slideStyles.getPropertyValue('padding-left'));
          const paddingRight = parseFloat(slideStyles.getPropertyValue('padding-right'));
          const marginLeft = parseFloat(slideStyles.getPropertyValue('margin-left'));
          const marginRight = parseFloat(slideStyles.getPropertyValue('margin-right'));
          const boxSizing = slideStyles.getPropertyValue('box-sizing');
          if (boxSizing && boxSizing === 'border-box' && !swiper_esm_bundle_Browser.isIE) {
            slideSize = width + marginLeft + marginRight;
          } else {
            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight;
          }
        } else {
          const height = parseFloat(slideStyles.getPropertyValue('height'));
          const paddingTop = parseFloat(slideStyles.getPropertyValue('padding-top'));
          const paddingBottom = parseFloat(slideStyles.getPropertyValue('padding-bottom'));
          const marginTop = parseFloat(slideStyles.getPropertyValue('margin-top'));
          const marginBottom = parseFloat(slideStyles.getPropertyValue('margin-bottom'));
          const boxSizing = slideStyles.getPropertyValue('box-sizing');
          if (boxSizing && boxSizing === 'border-box' && !swiper_esm_bundle_Browser.isIE) {
            slideSize = height + marginTop + marginBottom;
          } else {
            slideSize = height + paddingTop + paddingBottom + marginTop + marginBottom;
          }
        }
      }
      if (currentTransform) {
        slide[0].style.transform = currentTransform;
      }
      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = currentWebKitTransform;
      }
      if (params.roundLengths) slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - ((params.slidesPerView - 1) * spaceBetween)) / params.slidesPerView;
      if (params.roundLengths) slideSize = Math.floor(slideSize);

      if (slides[i]) {
        if (swiper.isHorizontal()) {
          slides[i].style.width = `${slideSize}px`;
        } else {
          slides[i].style.height = `${slideSize}px`;
        }
      }
    }
    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);


    if (params.centeredSlides) {
      slidePosition = slidePosition + (slideSize / 2) + (prevSlideSize / 2) + spaceBetween;
      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;
      if (i === 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index) % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index) % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }

    swiper.virtualSize += slideSize + spaceBetween;

    prevSlideSize = slideSize;

    index += 1;
  }
  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  let newSlidesGrid;

  if (
    rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
    $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
  }
  if (!swiper_esm_bundle_Support.flexbox || params.setWrapperSize) {
    if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
    else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });
  }

  if (params.slidesPerColumn > 1) {
    swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
    swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
    if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
    else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });
    if (params.centeredSlides) {
      newSlidesGrid = [];
      for (let i = 0; i < snapGrid.length; i += 1) {
        let slidesGridItem = snapGrid[i];
        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
      }
      snapGrid = newSlidesGrid;
    }
  }

  // Remove last grid elements depending on width
  if (!params.centeredSlides) {
    newSlidesGrid = [];
    for (let i = 0; i < snapGrid.length; i += 1) {
      let slidesGridItem = snapGrid[i];
      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(slidesGridItem);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }
  if (snapGrid.length === 0) snapGrid = [0];

  if (params.spaceBetween !== 0) {
    if (swiper.isHorizontal()) {
      if (rtl) slides.css({ marginLeft: `${spaceBetween}px` });
      else slides.css({ marginRight: `${spaceBetween}px` });
    } else slides.css({ marginBottom: `${spaceBetween}px` });
  }

  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;
    if (allSlidesSize < swiperSize) {
      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }

  Utils.extend(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid,
  });

  if (slidesLength !== previousSlidesLength) {
    swiper.emit('slidesLengthChange');
  }
  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow) swiper.checkOverflow();
    swiper.emit('snapGridLengthChange');
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit('slidesGridLengthChange');
  }

  if (params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateSlidesOffset();
  }
}

function updateAutoHeight (speed) {
  const swiper = this;
  const activeSlides = [];
  let newHeight = 0;
  let i;
  if (typeof speed === 'number') {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }
  // Find slides currently in view
  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
    for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
      const index = swiper.activeIndex + i;
      if (index > swiper.slides.length) break;
      activeSlides.push(swiper.slides.eq(index)[0]);
    }
  } else {
    activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
  }

  // Find new height from highest slide in view
  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== 'undefined') {
      const height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  }

  // Update Height
  if (newHeight) swiper.$wrapperEl.css('height', `${newHeight}px`);
}

function updateSlidesOffset () {
  const swiper = this;
  const slides = swiper.slides;
  for (let i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
  }
}

function updateSlidesProgress (translate = (this && this.translate) || 0) {
  const swiper = this;
  const params = swiper.params;

  const { slides, rtlTranslate: rtl } = swiper;

  if (slides.length === 0) return;
  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();

  let offsetCenter = -translate;
  if (rtl) offsetCenter = translate;

  // Visible Slides
  slides.removeClass(params.slideVisibleClass);

  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];

  for (let i = 0; i < slides.length; i += 1) {
    const slide = slides[i];
    const slideProgress = (
      (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0)) - slide.swiperSlideOffset
    ) / (slide.swiperSlideSize + params.spaceBetween);
    if (params.watchSlidesVisibility) {
      const slideBefore = -(offsetCenter - slide.swiperSlideOffset);
      const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
      const isVisible = (slideBefore >= 0 && slideBefore < swiper.size - 1)
                || (slideAfter > 1 && slideAfter <= swiper.size)
                || (slideBefore <= 0 && slideAfter >= swiper.size);
      if (isVisible) {
        swiper.visibleSlides.push(slide);
        swiper.visibleSlidesIndexes.push(i);
        slides.eq(i).addClass(params.slideVisibleClass);
      }
    }
    slide.progress = rtl ? -slideProgress : slideProgress;
  }
  swiper.visibleSlides = $(swiper.visibleSlides);
}

function updateProgress (translate = (this && this.translate) || 0) {
  const swiper = this;
  const params = swiper.params;

  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  let { progress, isBeginning, isEnd } = swiper;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate - swiper.minTranslate()) / (translatesDiff);
    isBeginning = progress <= 0;
    isEnd = progress >= 1;
  }
  Utils.extend(swiper, {
    progress,
    isBeginning,
    isEnd,
  });

  if (params.watchSlidesProgress || params.watchSlidesVisibility) swiper.updateSlidesProgress(translate);

  if (isBeginning && !wasBeginning) {
    swiper.emit('reachBeginning toEdge');
  }
  if (isEnd && !wasEnd) {
    swiper.emit('reachEnd toEdge');
  }
  if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {
    swiper.emit('fromEdge');
  }

  swiper.emit('progress', progress);
}

function updateSlidesClasses () {
  const swiper = this;

  const {
    slides, params, $wrapperEl, activeIndex, realIndex,
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;

  slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);

  let activeSlide;
  if (isVirtual) {
    activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
  } else {
    activeSlide = slides.eq(activeIndex);
  }

  // Active classes
  activeSlide.addClass(params.slideActiveClass);

  if (params.loop) {
    // Duplicate to all looped slides
    if (activeSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl
        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`)
        .addClass(params.slideDuplicateActiveClass);
    } else {
      $wrapperEl
        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`)
        .addClass(params.slideDuplicateActiveClass);
    }
  }
  // Next Slide
  let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
  if (params.loop && nextSlide.length === 0) {
    nextSlide = slides.eq(0);
    nextSlide.addClass(params.slideNextClass);
  }
  // Prev Slide
  let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
  if (params.loop && prevSlide.length === 0) {
    prevSlide = slides.eq(-1);
    prevSlide.addClass(params.slidePrevClass);
  }
  if (params.loop) {
    // Duplicate to all looped slides
    if (nextSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl
        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicateNextClass);
    } else {
      $wrapperEl
        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicateNextClass);
    }
    if (prevSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl
        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicatePrevClass);
    } else {
      $wrapperEl
        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicatePrevClass);
    }
  }
}

function updateActiveIndex (newActiveIndex) {
  const swiper = this;
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  const {
    slidesGrid, snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex,
  } = swiper;
  let activeIndex = newActiveIndex;
  let snapIndex;
  if (typeof activeIndex === 'undefined') {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - ((slidesGrid[i + 1] - slidesGrid[i]) / 2)) {
          activeIndex = i;
        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
          activeIndex = i + 1;
        }
      } else if (translate >= slidesGrid[i]) {
        activeIndex = i;
      }
    }
    // Normalize slideIndex
    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
    }
  }
  if (snapGrid.indexOf(translate) >= 0) {
    snapIndex = snapGrid.indexOf(translate);
  } else {
    snapIndex = Math.floor(activeIndex / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  if (activeIndex === previousIndex) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit('snapIndexChange');
    }
    return;
  }

  // Get real index
  const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);

  Utils.extend(swiper, {
    snapIndex,
    realIndex,
    previousIndex,
    activeIndex,
  });
  swiper.emit('activeIndexChange');
  swiper.emit('snapIndexChange');
  if (previousRealIndex !== realIndex) {
    swiper.emit('realIndexChange');
  }
  if (swiper.initialized || swiper.runCallbacksOnInit) {
    swiper.emit('slideChange');
  }
}

function updateClickedSlide (e) {
  const swiper = this;
  const params = swiper.params;
  const slide = $(e.target).closest(`.${params.slideClass}`)[0];
  let slideFound = false;
  if (slide) {
    for (let i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide) slideFound = true;
    }
  }

  if (slide && slideFound) {
    swiper.clickedSlide = slide;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
    } else {
      swiper.clickedIndex = $(slide).index();
    }
  } else {
    swiper.clickedSlide = undefined;
    swiper.clickedIndex = undefined;
    return;
  }
  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}

var update = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide,
};

function getTranslate (axis = this.isHorizontal() ? 'x' : 'y') {
  const swiper = this;

  const {
    params, rtlTranslate: rtl, translate, $wrapperEl,
  } = swiper;

  if (params.virtualTranslate) {
    return rtl ? -translate : translate;
  }

  let currentTranslate = Utils.getTranslate($wrapperEl[0], axis);
  if (rtl) currentTranslate = -currentTranslate;

  return currentTranslate || 0;
}

function setTranslate (translate, byController) {
  const swiper = this;
  const {
    rtlTranslate: rtl, params, $wrapperEl, progress,
  } = swiper;
  let x = 0;
  let y = 0;
  const z = 0;

  if (swiper.isHorizontal()) {
    x = rtl ? -translate : translate;
  } else {
    y = translate;
  }

  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }

  if (!params.virtualTranslate) {
    if (swiper_esm_bundle_Support.transforms3d) $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
    else $wrapperEl.transform(`translate(${x}px, ${y}px)`);
  }
  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x : y;

  // Check if we need to update progress
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate - swiper.minTranslate()) / (translatesDiff);
  }
  if (newProgress !== progress) {
    swiper.updateProgress(translate);
  }

  swiper.emit('setTranslate', swiper.translate, byController);
}

function minTranslate () {
  return (-this.snapGrid[0]);
}

function maxTranslate () {
  return (-this.snapGrid[this.snapGrid.length - 1]);
}

var swiper_esm_bundle_translate = {
  getTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
};

function setTransition (duration, byController) {
  const swiper = this;

  swiper.$wrapperEl.transition(duration);

  swiper.emit('setTransition', duration, byController);
}

function transitionStart (runCallbacks = true, direction) {
  const swiper = this;
  const { activeIndex, params, previousIndex } = swiper;
  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }

  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';
    else if (activeIndex < previousIndex) dir = 'prev';
    else dir = 'reset';
  }

  swiper.emit('transitionStart');

  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit('slideResetTransitionStart');
      return;
    }
    swiper.emit('slideChangeTransitionStart');
    if (dir === 'next') {
      swiper.emit('slideNextTransitionStart');
    } else {
      swiper.emit('slidePrevTransitionStart');
    }
  }
}

function swiper_esm_bundle_transitionEnd (runCallbacks = true, direction) {
  const swiper = this;
  const { activeIndex, previousIndex } = swiper;
  swiper.animating = false;
  swiper.setTransition(0);

  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';
    else if (activeIndex < previousIndex) dir = 'prev';
    else dir = 'reset';
  }

  swiper.emit('transitionEnd');

  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit('slideResetTransitionEnd');
      return;
    }
    swiper.emit('slideChangeTransitionEnd');
    if (dir === 'next') {
      swiper.emit('slideNextTransitionEnd');
    } else {
      swiper.emit('slidePrevTransitionEnd');
    }
  }
}

var swiper_esm_bundle_transition = {
  setTransition,
  transitionStart,
  transitionEnd: swiper_esm_bundle_transitionEnd,
};

function slideTo (index = 0, speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  let slideIndex = index;
  if (slideIndex < 0) slideIndex = 0;

  const {
    params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl,
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }

  let snapIndex = Math.floor(slideIndex / params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
    swiper.emit('beforeSlideChangeStart');
  }

  const translate = -snapGrid[snapIndex];

  // Update progress
  swiper.updateProgress(translate);

  // Normalize slideIndex
  if (params.normalizeSlideIndex) {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {
        slideIndex = i;
      }
    }
  }
  // Directions locks
  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
      return false;
    }
    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) return false;
    }
  }

  let direction;
  if (slideIndex > activeIndex) direction = 'next';
  else if (slideIndex < activeIndex) direction = 'prev';
  else direction = 'reset';


  // Update Index
  if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {
    swiper.updateActiveIndex(slideIndex);
    // Update Height
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    swiper.updateSlidesClasses();
    if (params.effect !== 'slide') {
      swiper.setTranslate(translate);
    }
    if (direction !== 'reset') {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }
    return false;
  }

  if (speed === 0 || !swiper_esm_bundle_Support.transition) {
    swiper.setTransition(0);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    swiper.transitionEnd(runCallbacks, direction);
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onSlideToWrapperTransitionEnd) {
        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
          swiper.onSlideToWrapperTransitionEnd = null;
          delete swiper.onSlideToWrapperTransitionEnd;
          swiper.transitionEnd(runCallbacks, direction);
        };
      }
      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
    }
  }

  return true;
}

function slideToLoop (index = 0, speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  let newIndex = index;
  if (swiper.params.loop) {
    newIndex += swiper.loopedSlides;
  }

  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideNext (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const { params, animating } = swiper;
  if (params.loop) {
    if (animating) return false;
    swiper.loopFix();
    // eslint-disable-next-line
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
    return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
  }
  return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slidePrev (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const {
    params, animating, snapGrid, slidesGrid, rtlTranslate,
  } = swiper;

  if (params.loop) {
    if (animating) return false;
    swiper.loopFix();
    // eslint-disable-next-line
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }
  const translate = rtlTranslate ? swiper.translate : -swiper.translate;
  function normalize(val) {
    if (val < 0) return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }
  const normalizedTranslate = normalize(translate);
  const normalizedSnapGrid = snapGrid.map((val) => normalize(val));
  const normalizedSlidesGrid = slidesGrid.map((val) => normalize(val));

  const currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
  const prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
  let prevIndex;
  if (typeof prevSnap !== 'undefined') {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
  }
  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideReset (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideToClosest (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  let index = swiper.activeIndex;
  const snapIndex = Math.floor(index / swiper.params.slidesPerGroup);

  if (snapIndex < swiper.snapGrid.length - 1) {
    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

    const currentSnap = swiper.snapGrid[snapIndex];
    const nextSnap = swiper.snapGrid[snapIndex + 1];

    if ((translate - currentSnap) > (nextSnap - currentSnap) / 2) {
      index = swiper.params.slidesPerGroup;
    }
  }

  return swiper.slideTo(index, speed, runCallbacks, internal);
}

function slideToClickedSlide () {
  const swiper = this;
  const { params, $wrapperEl } = swiper;

  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper.clickedIndex;
  let realIndex;
  if (params.loop) {
    if (swiper.animating) return;
    realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
    if (params.centeredSlides) {
      if (
        (slideToIndex < swiper.loopedSlides - (slidesPerView / 2))
        || (slideToIndex > (swiper.slides.length - swiper.loopedSlides) + (slidesPerView / 2))
      ) {
        swiper.loopFix();
        slideToIndex = $wrapperEl
          .children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`)
          .eq(0)
          .index();

        Utils.nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = $wrapperEl
        .children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`)
        .eq(0)
        .index();

      Utils.nextTick(() => {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}

var swiper_esm_bundle_slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide,
};

function loopCreate () {
  const swiper = this;
  const { params, $wrapperEl } = swiper;
  // Remove duplicated slides
  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();

  let slides = $wrapperEl.children(`.${params.slideClass}`);

  if (params.loopFillGroupWithBlank) {
    const blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);
    if (blankSlidesNum !== params.slidesPerGroup) {
      for (let i = 0; i < blankSlidesNum; i += 1) {
        const blankNode = $(ssr_window_esm_doc.createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
        $wrapperEl.append(blankNode);
      }
      slides = $wrapperEl.children(`.${params.slideClass}`);
    }
  }

  if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;

  swiper.loopedSlides = parseInt(params.loopedSlides || params.slidesPerView, 10);
  swiper.loopedSlides += params.loopAdditionalSlides;
  if (swiper.loopedSlides > slides.length) {
    swiper.loopedSlides = slides.length;
  }

  const prependSlides = [];
  const appendSlides = [];
  slides.each((index, el) => {
    const slide = $(el);
    if (index < swiper.loopedSlides) appendSlides.push(el);
    if (index < slides.length && index >= slides.length - swiper.loopedSlides) prependSlides.push(el);
    slide.attr('data-swiper-slide-index', index);
  });
  for (let i = 0; i < appendSlides.length; i += 1) {
    $wrapperEl.append($(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
  for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
    $wrapperEl.prepend($(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
}

function loopFix () {
  const swiper = this;
  const {
    params, activeIndex, slides, loopedSlides, allowSlidePrev, allowSlideNext, snapGrid, rtlTranslate: rtl,
  } = swiper;
  let newIndex;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;

  const snapTranslate = -snapGrid[activeIndex];
  const diff = snapTranslate - swiper.getTranslate();


  // Fix For Negative Oversliding
  if (activeIndex < loopedSlides) {
    newIndex = (slides.length - (loopedSlides * 3)) + activeIndex;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);
    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  } else if ((params.slidesPerView === 'auto' && activeIndex >= loopedSlides * 2) || (activeIndex >= slides.length - loopedSlides)) {
    // Fix For Positive Oversliding
    newIndex = -slides.length + activeIndex + loopedSlides;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);
    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
}

function loopDestroy () {
  const swiper = this;
  const { $wrapperEl, params, slides } = swiper;
  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
  slides.removeAttr('data-swiper-slide-index');
}

var loop = {
  loopCreate,
  loopFix,
  loopDestroy,
};

function setGrabCursor (moving) {
  const swiper = this;
  if (swiper_esm_bundle_Support.touch || !swiper.params.simulateTouch || (swiper.params.watchOverflow && swiper.isLocked)) return;
  const el = swiper.el;
  el.style.cursor = 'move';
  el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
  el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
  el.style.cursor = moving ? 'grabbing' : 'grab';
}

function unsetGrabCursor () {
  const swiper = this;
  if (swiper_esm_bundle_Support.touch || (swiper.params.watchOverflow && swiper.isLocked)) return;
  swiper.el.style.cursor = '';
}

var grabCursor = {
  setGrabCursor,
  unsetGrabCursor,
};

function appendSlide (slides) {
  const swiper = this;
  const { $wrapperEl, params } = swiper;
  if (params.loop) {
    swiper.loopDestroy();
  }
  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.append(slides[i]);
    }
  } else {
    $wrapperEl.append(slides);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && swiper_esm_bundle_Support.observer)) {
    swiper.update();
  }
}

function prependSlide (slides) {
  const swiper = this;
  const { params, $wrapperEl, activeIndex } = swiper;

  if (params.loop) {
    swiper.loopDestroy();
  }
  let newActiveIndex = activeIndex + 1;
  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.prepend(slides[i]);
    }
    newActiveIndex = activeIndex + slides.length;
  } else {
    $wrapperEl.prepend(slides);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && swiper_esm_bundle_Support.observer)) {
    swiper.update();
  }
  swiper.slideTo(newActiveIndex, 0, false);
}

function addSlide (index, slides) {
  const swiper = this;
  const { $wrapperEl, params, activeIndex } = swiper;
  let activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
  }
  const baseLength = swiper.slides.length;
  if (index <= 0) {
    swiper.prependSlide(slides);
    return;
  }
  if (index >= baseLength) {
    swiper.appendSlide(slides);
    return;
  }
  let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;

  const slidesBuffer = [];
  for (let i = baseLength - 1; i >= index; i -= 1) {
    const currentSlide = swiper.slides.eq(i);
    currentSlide.remove();
    slidesBuffer.unshift(currentSlide);
  }

  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.append(slides[i]);
    }
    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
  } else {
    $wrapperEl.append(slides);
  }

  for (let i = 0; i < slidesBuffer.length; i += 1) {
    $wrapperEl.append(slidesBuffer[i]);
  }

  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && swiper_esm_bundle_Support.observer)) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

function removeSlide (slidesIndexes) {
  const swiper = this;
  const { params, $wrapperEl, activeIndex } = swiper;

  let activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
  }
  let newActiveIndex = activeIndexBuffer;
  let indexToRemove;

  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
    for (let i = 0; i < slidesIndexes.length; i += 1) {
      indexToRemove = slidesIndexes[i];
      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    }
    newActiveIndex = Math.max(newActiveIndex, 0);
  } else {
    indexToRemove = slidesIndexes;
    if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    newActiveIndex = Math.max(newActiveIndex, 0);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!(params.observer && swiper_esm_bundle_Support.observer)) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

function removeAllSlides () {
  const swiper = this;

  const slidesIndexes = [];
  for (let i = 0; i < swiper.slides.length; i += 1) {
    slidesIndexes.push(i);
  }
  swiper.removeSlide(slidesIndexes);
}

var manipulation = {
  appendSlide,
  prependSlide,
  addSlide,
  removeSlide,
  removeAllSlides,
};

const swiper_esm_bundle_Device = (function Device() {
  const ua = ssr_window_esm_win.navigator.userAgent;

  const device = {
    ios: false,
    android: false,
    androidChrome: false,
    desktop: false,
    windows: false,
    iphone: false,
    ipod: false,
    ipad: false,
    cordova: ssr_window_esm_win.cordova || ssr_window_esm_win.phonegap,
    phonegap: ssr_window_esm_win.cordova || ssr_window_esm_win.phonegap,
  };

  const windows = ua.match(/(Windows Phone);?[\s\/]+([\d.]+)?/); // eslint-disable-line
  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
  const ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);


  // Windows
  if (windows) {
    device.os = 'windows';
    device.osVersion = windows[2];
    device.windows = true;
  }
  // Android
  if (android && !windows) {
    device.os = 'android';
    device.osVersion = android[2];
    device.android = true;
    device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;
  }
  if (ipad || iphone || ipod) {
    device.os = 'ios';
    device.ios = true;
  }
  // iOS
  if (iphone && !ipod) {
    device.osVersion = iphone[2].replace(/_/g, '.');
    device.iphone = true;
  }
  if (ipad) {
    device.osVersion = ipad[2].replace(/_/g, '.');
    device.ipad = true;
  }
  if (ipod) {
    device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
    device.iphone = true;
  }
  // iOS 8+ changed UA
  if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
    if (device.osVersion.split('.')[0] === '10') {
      device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
    }
  }

  // Desktop
  device.desktop = !(device.os || device.android || device.webView);

  // Webview
  device.webView = (iphone || ipad || ipod) && ua.match(/.*AppleWebKit(?!.*Safari)/i);

  // Minimal UI
  if (device.os && device.os === 'ios') {
    const osVersionArr = device.osVersion.split('.');
    const metaViewport = ssr_window_esm_doc.querySelector('meta[name="viewport"]');
    device.minimalUi = !device.webView
      && (ipod || iphone)
      && (osVersionArr[0] * 1 === 7 ? osVersionArr[1] * 1 >= 1 : osVersionArr[0] * 1 > 7)
      && metaViewport && metaViewport.getAttribute('content').indexOf('minimal-ui') >= 0;
  }

  // Pixel Ratio
  device.pixelRatio = ssr_window_esm_win.devicePixelRatio || 1;

  // Export object
  return device;
}());

function onTouchStart (event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  const { params, touches } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  data.isTouchEvent = e.type === 'touchstart';
  if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
  if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
  if (data.isTouched && data.isMoved) return;
  if (params.noSwiping && $(e.target).closest(params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`)[0]) {
    swiper.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!$(e).closest(params.swipeHandler)[0]) return;
  }

  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY;

  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore

  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
  if (
    edgeSwipeDetection
    && ((startX <= edgeSwipeThreshold)
    || (startX >= ssr_window_esm_win.screen.width - edgeSwipeThreshold))
  ) {
    return;
  }

  Utils.extend(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: undefined,
    startMoving: undefined,
  });

  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = Utils.now();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = undefined;
  if (params.threshold > 0) data.allowThresholdMove = false;
  if (e.type !== 'touchstart') {
    let preventDefault = true;
    if ($(e.target).is(data.formElements)) preventDefault = false;
    if (
      ssr_window_esm_doc.activeElement
      && $(ssr_window_esm_doc.activeElement).is(data.formElements)
      && ssr_window_esm_doc.activeElement !== e.target
    ) {
      ssr_window_esm_doc.activeElement.blur();
    }

    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
    if (params.touchStartForcePreventDefault || shouldPreventDefault) {
      e.preventDefault();
    }
  }
  swiper.emit('touchStart', e);
}

function onTouchMove (event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  const { params, touches, rtlTranslate: rtl } = swiper;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }
    return;
  }
  if (data.isTouchEvent && e.type === 'mousemove') return;
  const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
  const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper.allowTouchMove) {
    // isMoved = true;
    swiper.allowClick = false;
    if (data.isTouched) {
      Utils.extend(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY,
      });
      data.touchStartTime = Utils.now();
    }
    return;
  }
  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      // Vertical
      if (
        (pageY < touches.startY && swiper.translate <= swiper.maxTranslate())
        || (pageY > touches.startY && swiper.translate >= swiper.minTranslate())
      ) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (
      (pageX < touches.startX && swiper.translate <= swiper.maxTranslate())
      || (pageX > touches.startX && swiper.translate >= swiper.minTranslate())
    ) {
      return;
    }
  }
  if (data.isTouchEvent && ssr_window_esm_doc.activeElement) {
    if (e.target === ssr_window_esm_doc.activeElement && $(e.target).is(data.formElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }
  if (data.allowTouchCallbacks) {
    swiper.emit('touchMove', e);
  }
  if (e.targetTouches && e.targetTouches.length > 1) return;

  touches.currentX = pageX;
  touches.currentY = pageY;

  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt((diffX ** 2) + (diffY ** 2)) < swiper.params.threshold) return;

  if (typeof data.isScrolling === 'undefined') {
    let touchAngle;
    if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {
      data.isScrolling = false;
    } else {
      // eslint-disable-next-line
      if ((diffX * diffX) + (diffY * diffY) >= 25) {
        touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : (90 - touchAngle > params.touchAngle);
      }
    }
  }
  if (data.isScrolling) {
    swiper.emit('touchMoveOpposite', e);
  }
  if (typeof data.startMoving === 'undefined') {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }
  if (data.isScrolling) {
    data.isTouched = false;
    return;
  }
  if (!data.startMoving) {
    return;
  }
  swiper.allowClick = false;
  e.preventDefault();
  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }

  if (!data.isMoved) {
    if (params.loop) {
      swiper.loopFix();
    }
    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);
    if (swiper.animating) {
      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
    }
    data.allowMomentumBounce = false;
    // Grab Cursor
    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }
    swiper.emit('sliderFirstMove', e);
  }
  swiper.emit('sliderMove', e);
  data.isMoved = true;

  let diff = swiper.isHorizontal() ? diffX : diffY;
  touches.diff = diff;

  diff *= params.touchRatio;
  if (rtl) diff = -diff;

  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
  data.currentTranslate = diff + data.startTranslate;

  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if ((diff > 0 && data.currentTranslate > swiper.minTranslate())) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = (swiper.minTranslate() - 1) + ((-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio);
  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = (swiper.maxTranslate() + 1) - ((swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio);
  }

  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  }

  // Directions locks
  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }


  // Threshold
  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }

  if (!params.followFinger) return;

  // Update active index in free mode
  if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  if (params.freeMode) {
    // Velocity
    if (data.velocities.length === 0) {
      data.velocities.push({
        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
        time: data.touchStartTime,
      });
    }
    data.velocities.push({
      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
      time: Utils.now(),
    });
  }
  // Update progress
  swiper.updateProgress(data.currentTranslate);
  // Update translate
  swiper.setTranslate(data.currentTranslate);
}

function onTouchEnd (event) {
  const swiper = this;
  const data = swiper.touchEventsData;

  const {
    params, touches, rtlTranslate: rtl, $wrapperEl, slidesGrid, snapGrid,
  } = swiper;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (data.allowTouchCallbacks) {
    swiper.emit('touchEnd', e);
  }
  data.allowTouchCallbacks = false;
  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  // Return Grab Cursor
  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  }

  // Time diff
  const touchEndTime = Utils.now();
  const timeDiff = touchEndTime - data.touchStartTime;

  // Tap, doubleTap, Click
  if (swiper.allowClick) {
    swiper.updateClickedSlide(e);
    swiper.emit('tap', e);
    if (timeDiff < 300 && (touchEndTime - data.lastClickTime) > 300) {
      if (data.clickTimeout) clearTimeout(data.clickTimeout);
      data.clickTimeout = Utils.nextTick(() => {
        if (!swiper || swiper.destroyed) return;
        swiper.emit('click', e);
      }, 300);
    }
    if (timeDiff < 300 && (touchEndTime - data.lastClickTime) < 300) {
      if (data.clickTimeout) clearTimeout(data.clickTimeout);
      swiper.emit('doubleTap', e);
    }
  }

  data.lastClickTime = Utils.now();
  Utils.nextTick(() => {
    if (!swiper.destroyed) swiper.allowClick = true;
  });

  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;

  let currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }

  if (params.freeMode) {
    if (currentPos < -swiper.minTranslate()) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (currentPos > -swiper.maxTranslate()) {
      if (swiper.slides.length < snapGrid.length) {
        swiper.slideTo(snapGrid.length - 1);
      } else {
        swiper.slideTo(swiper.slides.length - 1);
      }
      return;
    }

    if (params.freeModeMomentum) {
      if (data.velocities.length > 1) {
        const lastMoveEvent = data.velocities.pop();
        const velocityEvent = data.velocities.pop();

        const distance = lastMoveEvent.position - velocityEvent.position;
        const time = lastMoveEvent.time - velocityEvent.time;
        swiper.velocity = distance / time;
        swiper.velocity /= 2;
        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
          swiper.velocity = 0;
        }
        // this implies that the user stopped moving a finger then released.
        // There would be no events with distance zero, so the last event is stale.
        if (time > 150 || (Utils.now() - lastMoveEvent.time) > 300) {
          swiper.velocity = 0;
        }
      } else {
        swiper.velocity = 0;
      }
      swiper.velocity *= params.freeModeMomentumVelocityRatio;

      data.velocities.length = 0;
      let momentumDuration = 1000 * params.freeModeMomentumRatio;
      const momentumDistance = swiper.velocity * momentumDuration;

      let newPosition = swiper.translate + momentumDistance;
      if (rtl) newPosition = -newPosition;

      let doBounce = false;
      let afterBouncePosition;
      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
      let needsLoopFix;
      if (newPosition < swiper.maxTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
            newPosition = swiper.maxTranslate() - bounceAmount;
          }
          afterBouncePosition = swiper.maxTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.maxTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (newPosition > swiper.minTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition - swiper.minTranslate() > bounceAmount) {
            newPosition = swiper.minTranslate() + bounceAmount;
          }
          afterBouncePosition = swiper.minTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.minTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (params.freeModeSticky) {
        let nextSlide;
        for (let j = 0; j < snapGrid.length; j += 1) {
          if (snapGrid[j] > -newPosition) {
            nextSlide = j;
            break;
          }
        }

        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
          newPosition = snapGrid[nextSlide];
        } else {
          newPosition = snapGrid[nextSlide - 1];
        }
        newPosition = -newPosition;
      }
      if (needsLoopFix) {
        swiper.once('transitionEnd', () => {
          swiper.loopFix();
        });
      }
      // Fix duration
      if (swiper.velocity !== 0) {
        if (rtl) {
          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
        } else {
          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
        }
      } else if (params.freeModeSticky) {
        swiper.slideToClosest();
        return;
      }

      if (params.freeModeMomentumBounce && doBounce) {
        swiper.updateProgress(afterBouncePosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        swiper.animating = true;
        $wrapperEl.transitionEnd(() => {
          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
          swiper.emit('momentumBounce');

          swiper.setTransition(params.speed);
          swiper.setTranslate(afterBouncePosition);
          $wrapperEl.transitionEnd(() => {
            if (!swiper || swiper.destroyed) return;
            swiper.transitionEnd();
          });
        });
      } else if (swiper.velocity) {
        swiper.updateProgress(newPosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        if (!swiper.animating) {
          swiper.animating = true;
          $wrapperEl.transitionEnd(() => {
            if (!swiper || swiper.destroyed) return;
            swiper.transitionEnd();
          });
        }
      } else {
        swiper.updateProgress(newPosition);
      }

      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    } else if (params.freeModeSticky) {
      swiper.slideToClosest();
      return;
    }

    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    return;
  }

  // Find current slide
  let stopIndex = 0;
  let groupSize = swiper.slidesSizesGrid[0];
  for (let i = 0; i < slidesGrid.length; i += params.slidesPerGroup) {
    if (typeof slidesGrid[i + params.slidesPerGroup] !== 'undefined') {
      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + params.slidesPerGroup]) {
        stopIndex = i;
        groupSize = slidesGrid[i + params.slidesPerGroup] - slidesGrid[i];
      }
    } else if (currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }

  // Find current slide size
  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;

  if (timeDiff > params.longSwipesMs) {
    // Long touches
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === 'next') {
      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + params.slidesPerGroup);
      else swiper.slideTo(stopIndex);
    }
    if (swiper.swipeDirection === 'prev') {
      if (ratio > (1 - params.longSwipesRatio)) swiper.slideTo(stopIndex + params.slidesPerGroup);
      else swiper.slideTo(stopIndex);
    }
  } else {
    // Short swipes
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === 'next') {
      swiper.slideTo(stopIndex + params.slidesPerGroup);
    }
    if (swiper.swipeDirection === 'prev') {
      swiper.slideTo(stopIndex);
    }
  }
}

function onResize () {
  const swiper = this;

  const { params, el } = swiper;

  if (el && el.offsetWidth === 0) return;

  // Breakpoints
  if (params.breakpoints) {
    swiper.setBreakpoint();
  }

  // Save locks
  const { allowSlideNext, allowSlidePrev, snapGrid } = swiper;

  // Disable locks on resize
  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;

  swiper.updateSize();
  swiper.updateSlides();

  if (params.freeMode) {
    const newTranslate = Math.min(Math.max(swiper.translate, swiper.maxTranslate()), swiper.minTranslate());
    swiper.setTranslate(newTranslate);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();

    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
  } else {
    swiper.updateSlidesClasses();
    if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
      swiper.slideTo(swiper.slides.length - 1, 0, false, true);
    } else {
      swiper.slideTo(swiper.activeIndex, 0, false, true);
    }
  }
  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    swiper.autoplay.run();
  }
  // Return locks after resize
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;

  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}

function swiper_esm_bundle_onClick (e) {
  const swiper = this;
  if (!swiper.allowClick) {
    if (swiper.params.preventClicks) e.preventDefault();
    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}

function attachEvents() {
  const swiper = this;
  const {
    params, touchEvents, el, wrapperEl,
  } = swiper;

  {
    swiper.onTouchStart = onTouchStart.bind(swiper);
    swiper.onTouchMove = onTouchMove.bind(swiper);
    swiper.onTouchEnd = onTouchEnd.bind(swiper);
  }

  swiper.onClick = swiper_esm_bundle_onClick.bind(swiper);

  const target = params.touchEventsTarget === 'container' ? el : wrapperEl;
  const capture = !!params.nested;

  // Touch Events
  {
    if (!swiper_esm_bundle_Support.touch && (swiper_esm_bundle_Support.pointerEvents || swiper_esm_bundle_Support.prefixedPointerEvents)) {
      target.addEventListener(touchEvents.start, swiper.onTouchStart, false);
      ssr_window_esm_doc.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
      ssr_window_esm_doc.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
    } else {
      if (swiper_esm_bundle_Support.touch) {
        const passiveListener = touchEvents.start === 'touchstart' && swiper_esm_bundle_Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
        target.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
        target.addEventListener(touchEvents.move, swiper.onTouchMove, swiper_esm_bundle_Support.passiveListener ? { passive: false, capture } : capture);
        target.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
      }
      if ((params.simulateTouch && !swiper_esm_bundle_Device.ios && !swiper_esm_bundle_Device.android) || (params.simulateTouch && !swiper_esm_bundle_Support.touch && swiper_esm_bundle_Device.ios)) {
        target.addEventListener('mousedown', swiper.onTouchStart, false);
        ssr_window_esm_doc.addEventListener('mousemove', swiper.onTouchMove, capture);
        ssr_window_esm_doc.addEventListener('mouseup', swiper.onTouchEnd, false);
      }
    }
    // Prevent Links Clicks
    if (params.preventClicks || params.preventClicksPropagation) {
      target.addEventListener('click', swiper.onClick, true);
    }
  }

  // Resize handler
  swiper.on((swiper_esm_bundle_Device.ios || swiper_esm_bundle_Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize, true);
}

function detachEvents() {
  const swiper = this;

  const {
    params, touchEvents, el, wrapperEl,
  } = swiper;

  const target = params.touchEventsTarget === 'container' ? el : wrapperEl;
  const capture = !!params.nested;

  // Touch Events
  {
    if (!swiper_esm_bundle_Support.touch && (swiper_esm_bundle_Support.pointerEvents || swiper_esm_bundle_Support.prefixedPointerEvents)) {
      target.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
      ssr_window_esm_doc.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
      ssr_window_esm_doc.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
    } else {
      if (swiper_esm_bundle_Support.touch) {
        const passiveListener = touchEvents.start === 'onTouchStart' && swiper_esm_bundle_Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
        target.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
        target.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
        target.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
      }
      if ((params.simulateTouch && !swiper_esm_bundle_Device.ios && !swiper_esm_bundle_Device.android) || (params.simulateTouch && !swiper_esm_bundle_Support.touch && swiper_esm_bundle_Device.ios)) {
        target.removeEventListener('mousedown', swiper.onTouchStart, false);
        ssr_window_esm_doc.removeEventListener('mousemove', swiper.onTouchMove, capture);
        ssr_window_esm_doc.removeEventListener('mouseup', swiper.onTouchEnd, false);
      }
    }
    // Prevent Links Clicks
    if (params.preventClicks || params.preventClicksPropagation) {
      target.removeEventListener('click', swiper.onClick, true);
    }
  }

  // Resize handler
  swiper.off((swiper_esm_bundle_Device.ios || swiper_esm_bundle_Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize);
}

var swiper_esm_bundle_events = {
  attachEvents,
  detachEvents,
};

function setBreakpoint () {
  const swiper = this;
  const {
    activeIndex, initialized, loopedSlides = 0, params,
  } = swiper;
  const breakpoints = params.breakpoints;
  if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) return;

  // Set breakpoint for window width and update parameters
  const breakpoint = swiper.getBreakpoint(breakpoints);

  if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
    const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
    if (breakpointOnlyParams) {
      ['slidesPerView', 'spaceBetween', 'slidesPerGroup'].forEach((param) => {
        const paramValue = breakpointOnlyParams[param];
        if (typeof paramValue === 'undefined') return;
        if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
          breakpointOnlyParams[param] = 'auto';
        } else if (param === 'slidesPerView') {
          breakpointOnlyParams[param] = parseFloat(paramValue);
        } else {
          breakpointOnlyParams[param] = parseInt(paramValue, 10);
        }
      });
    }

    const breakpointParams = breakpointOnlyParams || swiper.originalParams;
    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

    if (directionChanged && initialized) {
      swiper.changeDirection();
    }

    Utils.extend(swiper.params, breakpointParams);

    Utils.extend(swiper, {
      allowTouchMove: swiper.params.allowTouchMove,
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
    });

    swiper.currentBreakpoint = breakpoint;

    if (needsReLoop && initialized) {
      swiper.loopDestroy();
      swiper.loopCreate();
      swiper.updateSlides();
      swiper.slideTo((activeIndex - loopedSlides) + swiper.loopedSlides, 0, false);
    }

    swiper.emit('breakpoint', breakpointParams);
  }
}

function getBreakpoint (breakpoints) {
  const swiper = this;
  // Get breakpoint for window width
  if (!breakpoints) return undefined;
  let breakpoint = false;
  const points = [];
  Object.keys(breakpoints).forEach((point) => {
    points.push(point);
  });
  points.sort((a, b) => parseInt(a, 10) - parseInt(b, 10));
  for (let i = 0; i < points.length; i += 1) {
    const point = points[i];
    if (swiper.params.breakpointsInverse) {
      if (point <= ssr_window_esm_win.innerWidth) {
        breakpoint = point;
      }
    } else if (point >= ssr_window_esm_win.innerWidth && !breakpoint) {
      breakpoint = point;
    }
  }
  return breakpoint || 'max';
}

var swiper_esm_bundle_breakpoints = { setBreakpoint, getBreakpoint };

function addClasses () {
  const swiper = this;
  const {
    classNames, params, rtl, $el,
  } = swiper;
  const suffixes = [];

  suffixes.push('initialized');
  suffixes.push(params.direction);

  if (params.freeMode) {
    suffixes.push('free-mode');
  }
  if (!swiper_esm_bundle_Support.flexbox) {
    suffixes.push('no-flexbox');
  }
  if (params.autoHeight) {
    suffixes.push('autoheight');
  }
  if (rtl) {
    suffixes.push('rtl');
  }
  if (params.slidesPerColumn > 1) {
    suffixes.push('multirow');
  }
  if (swiper_esm_bundle_Device.android) {
    suffixes.push('android');
  }
  if (swiper_esm_bundle_Device.ios) {
    suffixes.push('ios');
  }
  // WP8 Touch Events Fix
  if ((swiper_esm_bundle_Browser.isIE || swiper_esm_bundle_Browser.isEdge) && (swiper_esm_bundle_Support.pointerEvents || swiper_esm_bundle_Support.prefixedPointerEvents)) {
    suffixes.push(`wp8-${params.direction}`);
  }

  suffixes.forEach((suffix) => {
    classNames.push(params.containerModifierClass + suffix);
  });

  $el.addClass(classNames.join(' '));
}

function removeClasses () {
  const swiper = this;
  const { $el, classNames } = swiper;

  $el.removeClass(classNames.join(' '));
}

var classes = { addClasses, removeClasses };

function loadImage (imageEl, src, srcset, sizes, checkForComplete, callback) {
  let image;
  function onReady() {
    if (callback) callback();
  }
  if (!imageEl.complete || !checkForComplete) {
    if (src) {
      image = new ssr_window_esm_win.Image();
      image.onload = onReady;
      image.onerror = onReady;
      if (sizes) {
        image.sizes = sizes;
      }
      if (srcset) {
        image.srcset = srcset;
      }
      if (src) {
        image.src = src;
      }
    } else {
      onReady();
    }
  } else {
    // image already loaded...
    onReady();
  }
}

function preloadImages () {
  const swiper = this;
  swiper.imagesToLoad = swiper.$el.find('img');
  function onReady() {
    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
    if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;
    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
      if (swiper.params.updateOnImagesReady) swiper.update();
      swiper.emit('imagesReady');
    }
  }
  for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
    const imageEl = swiper.imagesToLoad[i];
    swiper.loadImage(
      imageEl,
      imageEl.currentSrc || imageEl.getAttribute('src'),
      imageEl.srcset || imageEl.getAttribute('srcset'),
      imageEl.sizes || imageEl.getAttribute('sizes'),
      true,
      onReady
    );
  }
}

var swiper_esm_bundle_images = {
  loadImage,
  preloadImages,
};

function checkOverflow() {
  const swiper = this;
  const wasLocked = swiper.isLocked;

  swiper.isLocked = swiper.snapGrid.length === 1;
  swiper.allowSlideNext = !swiper.isLocked;
  swiper.allowSlidePrev = !swiper.isLocked;

  // events
  if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');

  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
    swiper.navigation.update();
  }
}

var checkOverflow$1 = { checkOverflow };

var defaults = {
  init: true,
  direction: 'horizontal',
  touchEventsTarget: 'container',
  initialSlide: 0,
  speed: 300,
  //
  preventInteractionOnTransition: false,

  // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,

  // Free mode
  freeMode: false,
  freeModeMomentum: true,
  freeModeMomentumRatio: 1,
  freeModeMomentumBounce: true,
  freeModeMomentumBounceRatio: 1,
  freeModeMomentumVelocityRatio: 1,
  freeModeSticky: false,
  freeModeMinimumVelocity: 0.02,

  // Autoheight
  autoHeight: false,

  // Set wrapper width
  setWrapperSize: false,

  // Virtual Translate
  virtualTranslate: false,

  // Effects
  effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

  // Breakpoints
  breakpoints: undefined,
  breakpointsInverse: false,

  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerColumn: 1,
  slidesPerColumnFill: 'column',
  slidesPerGroup: 1,
  centeredSlides: false,
  slidesOffsetBefore: 0, // in px
  slidesOffsetAfter: 0, // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,

  // Disable swiper and hide navigation when container not overflow
  watchOverflow: false,

  // Round length
  roundLengths: false,

  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 0,
  touchMoveStopPropagation: true,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,

  // Unique Navigation Elements
  uniqueNavElements: true,

  // Resistance
  resistance: true,
  resistanceRatio: 0.85,

  // Progress
  watchSlidesProgress: false,
  watchSlidesVisibility: false,

  // Cursor
  grabCursor: false,

  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,

  // Images
  preloadImages: true,
  updateOnImagesReady: true,

  // loop
  loop: false,
  loopAdditionalSlides: 0,
  loopedSlides: null,
  loopFillGroupWithBlank: false,

  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null, // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: 'swiper-no-swiping',
  noSwipingSelector: null,

  // Passive Listeners
  passiveListeners: true,

  // NS
  containerModifierClass: 'swiper-container-', // NEW
  slideClass: 'swiper-slide',
  slideBlankClass: 'swiper-slide-invisible-blank',
  slideActiveClass: 'swiper-slide-active',
  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
  slideVisibleClass: 'swiper-slide-visible',
  slideDuplicateClass: 'swiper-slide-duplicate',
  slideNextClass: 'swiper-slide-next',
  slideDuplicateNextClass: 'swiper-slide-duplicate-next',
  slidePrevClass: 'swiper-slide-prev',
  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
  wrapperClass: 'swiper-wrapper',

  // Callbacks
  runCallbacksOnInit: true,
};

/* eslint no-param-reassign: "off" */

const prototypes = {
  update,
  translate: swiper_esm_bundle_translate,
  transition: swiper_esm_bundle_transition,
  slide: swiper_esm_bundle_slide,
  loop,
  grabCursor,
  manipulation,
  events: swiper_esm_bundle_events,
  breakpoints: swiper_esm_bundle_breakpoints,
  checkOverflow: checkOverflow$1,
  classes,
  images: swiper_esm_bundle_images,
};

const extendedDefaults = {};

class swiper_esm_bundle_Swiper extends SwiperClass {
  constructor(...args) {
    let el;
    let params;
    if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {
      params = args[0];
    } else {
      [el, params] = args;
    }
    if (!params) params = {};

    params = Utils.extend({}, params);
    if (el && !params.el) params.el = el;

    super(params);

    Object.keys(prototypes).forEach((prototypeGroup) => {
      Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
        if (!swiper_esm_bundle_Swiper.prototype[protoMethod]) {
          swiper_esm_bundle_Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
        }
      });
    });

    // Swiper Instance
    const swiper = this;
    if (typeof swiper.modules === 'undefined') {
      swiper.modules = {};
    }
    Object.keys(swiper.modules).forEach((moduleName) => {
      const module = swiper.modules[moduleName];
      if (module.params) {
        const moduleParamName = Object.keys(module.params)[0];
        const moduleParams = module.params[moduleParamName];
        if (typeof moduleParams !== 'object' || moduleParams === null) return;
        if (!(moduleParamName in params && 'enabled' in moduleParams)) return;
        if (params[moduleParamName] === true) {
          params[moduleParamName] = { enabled: true };
        }
        if (
          typeof params[moduleParamName] === 'object'
          && !('enabled' in params[moduleParamName])
        ) {
          params[moduleParamName].enabled = true;
        }
        if (!params[moduleParamName]) params[moduleParamName] = { enabled: false };
      }
    });

    // Extend defaults with modules params
    const swiperParams = Utils.extend({}, defaults);
    swiper.useModulesParams(swiperParams);

    // Extend defaults with passed params
    swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = Utils.extend({}, swiper.params);
    swiper.passedParams = Utils.extend({}, params);

    // Save Dom lib
    swiper.$ = $;

    // Find el
    const $el = $(swiper.params.el);
    el = $el[0];

    if (!el) {
      return undefined;
    }

    if ($el.length > 1) {
      const swipers = [];
      $el.each((index, containerEl) => {
        const newParams = Utils.extend({}, params, { el: containerEl });
        swipers.push(new swiper_esm_bundle_Swiper(newParams));
      });
      return swipers;
    }

    el.swiper = swiper;
    $el.data('swiper', swiper);

    // Find Wrapper
    const $wrapperEl = $el.children(`.${swiper.params.wrapperClass}`);

    // Extend Swiper
    Utils.extend(swiper, {
      $el,
      el,
      $wrapperEl,
      wrapperEl: $wrapperEl[0],

      // Classes
      classNames: [],

      // Slides
      slides: $(),
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],

      // isDirection
      isHorizontal() {
        return swiper.params.direction === 'horizontal';
      },
      isVertical() {
        return swiper.params.direction === 'vertical';
      },
      // RTL
      rtl: (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
      wrongRTL: $wrapperEl.css('display') === '-webkit-box',

      // Indexes
      activeIndex: 0,
      realIndex: 0,

      //
      isBeginning: true,
      isEnd: false,

      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,

      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,

      // Touch Events
      touchEvents: (function touchEvents() {
        const touch = ['touchstart', 'touchmove', 'touchend'];
        let desktop = ['mousedown', 'mousemove', 'mouseup'];
        if (swiper_esm_bundle_Support.pointerEvents) {
          desktop = ['pointerdown', 'pointermove', 'pointerup'];
        } else if (swiper_esm_bundle_Support.prefixedPointerEvents) {
          desktop = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp'];
        }
        swiper.touchEventsTouch = {
          start: touch[0],
          move: touch[1],
          end: touch[2],
        };
        swiper.touchEventsDesktop = {
          start: desktop[0],
          move: desktop[1],
          end: desktop[2],
        };
        return swiper_esm_bundle_Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
      }()),
      touchEventsData: {
        isTouched: undefined,
        isMoved: undefined,
        allowTouchCallbacks: undefined,
        touchStartTime: undefined,
        isScrolling: undefined,
        currentTranslate: undefined,
        startTranslate: undefined,
        allowThresholdMove: undefined,
        // Form elements to match
        formElements: 'input, select, option, textarea, button, video',
        // Last click time
        lastClickTime: Utils.now(),
        clickTimeout: undefined,
        // Velocities
        velocities: [],
        allowMomentumBounce: undefined,
        isTouchEvent: undefined,
        startMoving: undefined,
      },

      // Clicks
      allowClick: true,

      // Touches
      allowTouchMove: swiper.params.allowTouchMove,

      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0,
      },

      // Images
      imagesToLoad: [],
      imagesLoaded: 0,

    });

    // Install Modules
    swiper.useModules();

    // Init
    if (swiper.params.init) {
      swiper.init();
    }

    // Return app instance
    return swiper;
  }

  slidesPerViewDynamic() {
    const swiper = this;
    const {
      params, slides, slidesGrid, size: swiperSize, activeIndex,
    } = swiper;
    let spv = 1;
    if (params.centeredSlides) {
      let slideSize = slides[activeIndex].swiperSlideSize;
      let breakLoop;
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
      for (let i = activeIndex - 1; i >= 0; i -= 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
    } else {
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slidesGrid[i] - slidesGrid[activeIndex] < swiperSize) {
          spv += 1;
        }
      }
    }
    return spv;
  }

  update() {
    const swiper = this;
    if (!swiper || swiper.destroyed) return;
    const { snapGrid, params } = swiper;
    // Breakpoints
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();

    function setTranslate() {
      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    let translated;
    if (swiper.params.freeMode) {
      setTranslate();
      if (swiper.params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
      if (!translated) {
        setTranslate();
      }
    }
    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
    swiper.emit('update');
  }

  changeDirection(newDirection, needUpdate = true) {
    const swiper = this;
    const currentDirection = swiper.params.direction;
    if (!newDirection) {
      // eslint-disable-next-line
      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
    }
    if ((newDirection === currentDirection) || (newDirection !== 'horizontal' && newDirection !== 'vertical')) {
      return swiper;
    }

    swiper.$el
      .removeClass(`${swiper.params.containerModifierClass}${currentDirection} wp8-${currentDirection}`)
      .addClass(`${swiper.params.containerModifierClass}${newDirection}`);

    if ((swiper_esm_bundle_Browser.isIE || swiper_esm_bundle_Browser.isEdge) && (swiper_esm_bundle_Support.pointerEvents || swiper_esm_bundle_Support.prefixedPointerEvents)) {
      swiper.$el.addClass(`${swiper.params.containerModifierClass}wp8-${newDirection}`);
    }

    swiper.params.direction = newDirection;

    swiper.slides.each((slideIndex, slideEl) => {
      if (newDirection === 'vertical') {
        slideEl.style.width = '';
      } else {
        slideEl.style.height = '';
      }
    });

    swiper.emit('changeDirection');
    if (needUpdate) swiper.update();

    return swiper;
  }

  init() {
    const swiper = this;
    if (swiper.initialized) return;

    swiper.emit('beforeInit');

    // Set breakpoint
    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    }

    // Add Classes
    swiper.addClasses();

    // Create loop
    if (swiper.params.loop) {
      swiper.loopCreate();
    }

    // Update size
    swiper.updateSize();

    // Update slides
    swiper.updateSlides();

    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    }

    // Set Grab Cursor
    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }

    if (swiper.params.preloadImages) {
      swiper.preloadImages();
    }

    // Slide To Initial Slide
    if (swiper.params.loop) {
      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
    }

    // Attach events
    swiper.attachEvents();

    // Init Flag
    swiper.initialized = true;

    // Emit
    swiper.emit('init');
  }

  destroy(deleteInstance = true, cleanStyles = true) {
    const swiper = this;
    const {
      params, $el, $wrapperEl, slides,
    } = swiper;

    if (typeof swiper.params === 'undefined' || swiper.destroyed) {
      return null;
    }

    swiper.emit('beforeDestroy');

    // Init Flag
    swiper.initialized = false;

    // Detach events
    swiper.detachEvents();

    // Destroy loop
    if (params.loop) {
      swiper.loopDestroy();
    }

    // Cleanup styles
    if (cleanStyles) {
      swiper.removeClasses();
      $el.removeAttr('style');
      $wrapperEl.removeAttr('style');
      if (slides && slides.length) {
        slides
          .removeClass([
            params.slideVisibleClass,
            params.slideActiveClass,
            params.slideNextClass,
            params.slidePrevClass,
          ].join(' '))
          .removeAttr('style')
          .removeAttr('data-swiper-slide-index')
          .removeAttr('data-swiper-column')
          .removeAttr('data-swiper-row');
      }
    }

    swiper.emit('destroy');

    // Detach emitter events
    Object.keys(swiper.eventsListeners).forEach((eventName) => {
      swiper.off(eventName);
    });

    if (deleteInstance !== false) {
      swiper.$el[0].swiper = null;
      swiper.$el.data('swiper', null);
      Utils.deleteProps(swiper);
    }
    swiper.destroyed = true;

    return null;
  }

  static extendDefaults(newDefaults) {
    Utils.extend(extendedDefaults, newDefaults);
  }

  static get extendedDefaults() {
    return extendedDefaults;
  }

  static get defaults() {
    return defaults;
  }

  static get Class() {
    return SwiperClass;
  }

  static get $() {
    return $;
  }
}

var Device$1 = {
  name: 'device',
  proto: {
    device: swiper_esm_bundle_Device,
  },
  static: {
    device: swiper_esm_bundle_Device,
  },
};

var Support$1 = {
  name: 'support',
  proto: {
    support: swiper_esm_bundle_Support,
  },
  static: {
    support: swiper_esm_bundle_Support,
  },
};

var Browser$1 = {
  name: 'browser',
  proto: {
    browser: swiper_esm_bundle_Browser,
  },
  static: {
    browser: swiper_esm_bundle_Browser,
  },
};

var Resize = {
  name: 'resize',
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      resize: {
        resizeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.emit('beforeResize');
          swiper.emit('resize');
        },
        orientationChangeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.emit('orientationchange');
        },
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      // Emit resize
      ssr_window_esm_win.addEventListener('resize', swiper.resize.resizeHandler);

      // Emit orientationchange
      ssr_window_esm_win.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    },
    destroy() {
      const swiper = this;
      ssr_window_esm_win.removeEventListener('resize', swiper.resize.resizeHandler);
      ssr_window_esm_win.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    },
  },
};

const Observer = {
  func: ssr_window_esm_win.MutationObserver || ssr_window_esm_win.WebkitMutationObserver,
  attach(target, options = {}) {
    const swiper = this;

    const ObserverFunc = Observer.func;
    const observer = new ObserverFunc((mutations) => {
      // The observerUpdate event should only be triggered
      // once despite the number of mutations.  Additional
      // triggers are redundant and are very costly
      if (mutations.length === 1) {
        swiper.emit('observerUpdate', mutations[0]);
        return;
      }
      const observerUpdate = function observerUpdate() {
        swiper.emit('observerUpdate', mutations[0]);
      };

      if (ssr_window_esm_win.requestAnimationFrame) {
        ssr_window_esm_win.requestAnimationFrame(observerUpdate);
      } else {
        ssr_window_esm_win.setTimeout(observerUpdate, 0);
      }
    });

    observer.observe(target, {
      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
      childList: typeof options.childList === 'undefined' ? true : options.childList,
      characterData: typeof options.characterData === 'undefined' ? true : options.characterData,
    });

    swiper.observer.observers.push(observer);
  },
  init() {
    const swiper = this;
    if (!swiper_esm_bundle_Support.observer || !swiper.params.observer) return;
    if (swiper.params.observeParents) {
      const containerParents = swiper.$el.parents();
      for (let i = 0; i < containerParents.length; i += 1) {
        swiper.observer.attach(containerParents[i]);
      }
    }
    // Observe container
    swiper.observer.attach(swiper.$el[0], { childList: swiper.params.observeSlideChildren });

    // Observe wrapper
    swiper.observer.attach(swiper.$wrapperEl[0], { attributes: false });
  },
  destroy() {
    const swiper = this;
    swiper.observer.observers.forEach((observer) => {
      observer.disconnect();
    });
    swiper.observer.observers = [];
  },
};

var Observer$1 = {
  name: 'observer',
  params: {
    observer: false,
    observeParents: false,
    observeSlideChildren: false,
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      observer: {
        init: Observer.init.bind(swiper),
        attach: Observer.attach.bind(swiper),
        destroy: Observer.destroy.bind(swiper),
        observers: [],
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.observer.init();
    },
    destroy() {
      const swiper = this;
      swiper.observer.destroy();
    },
  },
};

const Virtual = {
  update(force) {
    const swiper = this;
    const { slidesPerView, slidesPerGroup, centeredSlides } = swiper.params;
    const { addSlidesBefore, addSlidesAfter } = swiper.params.virtual;
    const {
      from: previousFrom,
      to: previousTo,
      slides,
      slidesGrid: previousSlidesGrid,
      renderSlide,
      offset: previousOffset,
    } = swiper.virtual;
    swiper.updateActiveIndex();
    const activeIndex = swiper.activeIndex || 0;

    let offsetProp;
    if (swiper.rtlTranslate) offsetProp = 'right';
    else offsetProp = swiper.isHorizontal() ? 'left' : 'top';

    let slidesAfter;
    let slidesBefore;
    if (centeredSlides) {
      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
    } else {
      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesBefore;
      slidesBefore = slidesPerGroup + addSlidesAfter;
    }
    const from = Math.max((activeIndex || 0) - slidesBefore, 0);
    const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
    const offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);

    Utils.extend(swiper.virtual, {
      from,
      to,
      offset,
      slidesGrid: swiper.slidesGrid,
    });

    function onRendered() {
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();
      if (swiper.lazy && swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    }

    if (previousFrom === from && previousTo === to && !force) {
      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
        swiper.slides.css(offsetProp, `${offset}px`);
      }
      swiper.updateProgress();
      return;
    }
    if (swiper.params.virtual.renderExternal) {
      swiper.params.virtual.renderExternal.call(swiper, {
        offset,
        from,
        to,
        slides: (function getSlides() {
          const slidesToRender = [];
          for (let i = from; i <= to; i += 1) {
            slidesToRender.push(slides[i]);
          }
          return slidesToRender;
        }()),
      });
      onRendered();
      return;
    }
    const prependIndexes = [];
    const appendIndexes = [];
    if (force) {
      swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();
    } else {
      for (let i = previousFrom; i <= previousTo; i += 1) {
        if (i < from || i > to) {
          swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index="${i}"]`).remove();
        }
      }
    }
    for (let i = 0; i < slides.length; i += 1) {
      if (i >= from && i <= to) {
        if (typeof previousTo === 'undefined' || force) {
          appendIndexes.push(i);
        } else {
          if (i > previousTo) appendIndexes.push(i);
          if (i < previousFrom) prependIndexes.push(i);
        }
      }
    }
    appendIndexes.forEach((index) => {
      swiper.$wrapperEl.append(renderSlide(slides[index], index));
    });
    prependIndexes.sort((a, b) => b - a).forEach((index) => {
      swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
    });
    swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset}px`);
    onRendered();
  },
  renderSlide(slide, index) {
    const swiper = this;
    const params = swiper.params.virtual;
    if (params.cache && swiper.virtual.cache[index]) {
      return swiper.virtual.cache[index];
    }
    const $slideEl = params.renderSlide
      ? $(params.renderSlide.call(swiper, slide, index))
      : $(`<div class="${swiper.params.slideClass}" data-swiper-slide-index="${index}">${slide}</div>`);
    if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);
    if (params.cache) swiper.virtual.cache[index] = $slideEl;
    return $slideEl;
  },
  appendSlide(slides) {
    const swiper = this;
    if (typeof slides === 'object' && 'length' in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.push(slides[i]);
      }
    } else {
      swiper.virtual.slides.push(slides);
    }
    swiper.virtual.update(true);
  },
  prependSlide(slides) {
    const swiper = this;
    const activeIndex = swiper.activeIndex;
    let newActiveIndex = activeIndex + 1;
    let numberOfNewSlides = 1;

    if (Array.isArray(slides)) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
      }
      newActiveIndex = activeIndex + slides.length;
      numberOfNewSlides = slides.length;
    } else {
      swiper.virtual.slides.unshift(slides);
    }
    if (swiper.params.virtual.cache) {
      const cache = swiper.virtual.cache;
      const newCache = {};
      Object.keys(cache).forEach((cachedIndex) => {
        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cache[cachedIndex];
      });
      swiper.virtual.cache = newCache;
    }
    swiper.virtual.update(true);
    swiper.slideTo(newActiveIndex, 0);
  },
  removeSlide(slidesIndexes) {
    const swiper = this;
    if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
    let activeIndex = swiper.activeIndex;
    if (Array.isArray(slidesIndexes)) {
      for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
        swiper.virtual.slides.splice(slidesIndexes[i], 1);
        if (swiper.params.virtual.cache) {
          delete swiper.virtual.cache[slidesIndexes[i]];
        }
        if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
        activeIndex = Math.max(activeIndex, 0);
      }
    } else {
      swiper.virtual.slides.splice(slidesIndexes, 1);
      if (swiper.params.virtual.cache) {
        delete swiper.virtual.cache[slidesIndexes];
      }
      if (slidesIndexes < activeIndex) activeIndex -= 1;
      activeIndex = Math.max(activeIndex, 0);
    }
    swiper.virtual.update(true);
    swiper.slideTo(activeIndex, 0);
  },
  removeAllSlides() {
    const swiper = this;
    swiper.virtual.slides = [];
    if (swiper.params.virtual.cache) {
      swiper.virtual.cache = {};
    }
    swiper.virtual.update(true);
    swiper.slideTo(0, 0);
  },
};

var Virtual$1 = {
  name: 'virtual',
  params: {
    virtual: {
      enabled: false,
      slides: [],
      cache: true,
      renderSlide: null,
      renderExternal: null,
      addSlidesBefore: 0,
      addSlidesAfter: 0,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      virtual: {
        update: Virtual.update.bind(swiper),
        appendSlide: Virtual.appendSlide.bind(swiper),
        prependSlide: Virtual.prependSlide.bind(swiper),
        removeSlide: Virtual.removeSlide.bind(swiper),
        removeAllSlides: Virtual.removeAllSlides.bind(swiper),
        renderSlide: Virtual.renderSlide.bind(swiper),
        slides: swiper.params.virtual.slides,
        cache: {},
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (!swiper.params.virtual.enabled) return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
      const overwriteParams = {
        watchSlidesProgress: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);

      if (!swiper.params.initialSlide) {
        swiper.virtual.update();
      }
    },
    setTranslate() {
      const swiper = this;
      if (!swiper.params.virtual.enabled) return;
      swiper.virtual.update();
    },
  },
};

const Keyboard = {
  handle(event) {
    const swiper = this;
    const { rtlTranslate: rtl } = swiper;
    let e = event;
    if (e.originalEvent) e = e.originalEvent; // jquery fix
    const kc = e.keyCode || e.charCode;
    // Directions locks
    if (!swiper.allowSlideNext && ((swiper.isHorizontal() && kc === 39) || (swiper.isVertical() && kc === 40) || kc === 34)) {
      return false;
    }
    if (!swiper.allowSlidePrev && ((swiper.isHorizontal() && kc === 37) || (swiper.isVertical() && kc === 38) || kc === 33)) {
      return false;
    }
    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
      return undefined;
    }
    if (ssr_window_esm_doc.activeElement && ssr_window_esm_doc.activeElement.nodeName && (ssr_window_esm_doc.activeElement.nodeName.toLowerCase() === 'input' || ssr_window_esm_doc.activeElement.nodeName.toLowerCase() === 'textarea')) {
      return undefined;
    }
    if (swiper.params.keyboard.onlyInViewport && (kc === 33 || kc === 34 || kc === 37 || kc === 39 || kc === 38 || kc === 40)) {
      let inView = false;
      // Check that swiper should be inside of visible area of window
      if (swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 && swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0) {
        return undefined;
      }
      const windowWidth = ssr_window_esm_win.innerWidth;
      const windowHeight = ssr_window_esm_win.innerHeight;
      const swiperOffset = swiper.$el.offset();
      if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
      const swiperCoord = [
        [swiperOffset.left, swiperOffset.top],
        [swiperOffset.left + swiper.width, swiperOffset.top],
        [swiperOffset.left, swiperOffset.top + swiper.height],
        [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height],
      ];
      for (let i = 0; i < swiperCoord.length; i += 1) {
        const point = swiperCoord[i];
        if (
          point[0] >= 0 && point[0] <= windowWidth
          && point[1] >= 0 && point[1] <= windowHeight
        ) {
          inView = true;
        }
      }
      if (!inView) return undefined;
    }
    if (swiper.isHorizontal()) {
      if (kc === 33 || kc === 34 || kc === 37 || kc === 39) {
        if (e.preventDefault) e.preventDefault();
        else e.returnValue = false;
      }
      if (((kc === 34 || kc === 39) && !rtl) || ((kc === 33 || kc === 37) && rtl)) swiper.slideNext();
      if (((kc === 33 || kc === 37) && !rtl) || ((kc === 34 || kc === 39) && rtl)) swiper.slidePrev();
    } else {
      if (kc === 33 || kc === 34 || kc === 38 || kc === 40) {
        if (e.preventDefault) e.preventDefault();
        else e.returnValue = false;
      }
      if (kc === 34 || kc === 40) swiper.slideNext();
      if (kc === 33 || kc === 38) swiper.slidePrev();
    }
    swiper.emit('keyPress', kc);
    return undefined;
  },
  enable() {
    const swiper = this;
    if (swiper.keyboard.enabled) return;
    $(ssr_window_esm_doc).on('keydown', swiper.keyboard.handle);
    swiper.keyboard.enabled = true;
  },
  disable() {
    const swiper = this;
    if (!swiper.keyboard.enabled) return;
    $(ssr_window_esm_doc).off('keydown', swiper.keyboard.handle);
    swiper.keyboard.enabled = false;
  },
};

var Keyboard$1 = {
  name: 'keyboard',
  params: {
    keyboard: {
      enabled: false,
      onlyInViewport: true,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      keyboard: {
        enabled: false,
        enable: Keyboard.enable.bind(swiper),
        disable: Keyboard.disable.bind(swiper),
        handle: Keyboard.handle.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.keyboard.enabled) {
        swiper.keyboard.enable();
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.keyboard.enabled) {
        swiper.keyboard.disable();
      }
    },
  },
};

function isEventSupported() {
  const eventName = 'onwheel';
  let isSupported = eventName in ssr_window_esm_doc;

  if (!isSupported) {
    const element = ssr_window_esm_doc.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported
    && ssr_window_esm_doc.implementation
    && ssr_window_esm_doc.implementation.hasFeature
    // always returns true in newer browsers as per the standard.
    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
    && ssr_window_esm_doc.implementation.hasFeature('', '') !== true
  ) {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = ssr_window_esm_doc.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}
const Mousewheel = {
  lastScrollTime: Utils.now(),
  event: (function getEvent() {
    if (ssr_window_esm_win.navigator.userAgent.indexOf('firefox') > -1) return 'DOMMouseScroll';
    return isEventSupported() ? 'wheel' : 'mousewheel';
  }()),
  normalize(e) {
    // Reasonable defaults
    const PIXEL_STEP = 10;
    const LINE_HEIGHT = 40;
    const PAGE_HEIGHT = 800;

    let sX = 0;
    let sY = 0; // spinX, spinY
    let pX = 0;
    let pY = 0; // pixelX, pixelY

    // Legacy
    if ('detail' in e) {
      sY = e.detail;
    }
    if ('wheelDelta' in e) {
      sY = -e.wheelDelta / 120;
    }
    if ('wheelDeltaY' in e) {
      sY = -e.wheelDeltaY / 120;
    }
    if ('wheelDeltaX' in e) {
      sX = -e.wheelDeltaX / 120;
    }

    // side scrolling on FF with DOMMouseScroll
    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }

    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;

    if ('deltaY' in e) {
      pY = e.deltaY;
    }
    if ('deltaX' in e) {
      pX = e.deltaX;
    }

    if ((pX || pY) && e.deltaMode) {
      if (e.deltaMode === 1) { // delta in LINE units
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else { // delta in PAGE units
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    }

    // Fall-back if spin cannot be determined
    if (pX && !sX) {
      sX = (pX < 1) ? -1 : 1;
    }
    if (pY && !sY) {
      sY = (pY < 1) ? -1 : 1;
    }

    return {
      spinX: sX,
      spinY: sY,
      pixelX: pX,
      pixelY: pY,
    };
  },
  handleMouseEnter() {
    const swiper = this;
    swiper.mouseEntered = true;
  },
  handleMouseLeave() {
    const swiper = this;
    swiper.mouseEntered = false;
  },
  handle(event) {
    let e = event;
    const swiper = this;
    const params = swiper.params.mousewheel;

    if (!swiper.mouseEntered && !params.releaseOnEdges) return true;

    if (e.originalEvent) e = e.originalEvent; // jquery fix
    let delta = 0;
    const rtlFactor = swiper.rtlTranslate ? -1 : 1;

    const data = Mousewheel.normalize(e);

    if (params.forceToAxis) {
      if (swiper.isHorizontal()) {
        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = data.pixelX * rtlFactor;
        else return true;
      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = data.pixelY;
      else return true;
    } else {
      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
    }

    if (delta === 0) return true;

    if (params.invert) delta = -delta;

    if (!swiper.params.freeMode) {
      if (Utils.now() - swiper.mousewheel.lastScrollTime > 60) {
        if (delta < 0) {
          if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
            swiper.slideNext();
            swiper.emit('scroll', e);
          } else if (params.releaseOnEdges) return true;
        } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
          swiper.slidePrev();
          swiper.emit('scroll', e);
        } else if (params.releaseOnEdges) return true;
      }
      swiper.mousewheel.lastScrollTime = (new ssr_window_esm_win.Date()).getTime();
    } else {
      // Freemode or scrollContainer:
      if (swiper.params.loop) {
        swiper.loopFix();
      }
      let position = swiper.getTranslate() + (delta * params.sensitivity);
      const wasBeginning = swiper.isBeginning;
      const wasEnd = swiper.isEnd;

      if (position >= swiper.minTranslate()) position = swiper.minTranslate();
      if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();

      swiper.setTransition(0);
      swiper.setTranslate(position);
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();

      if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {
        swiper.updateSlidesClasses();
      }

      if (swiper.params.freeModeSticky) {
        clearTimeout(swiper.mousewheel.timeout);
        swiper.mousewheel.timeout = Utils.nextTick(() => {
          swiper.slideToClosest();
        }, 300);
      }
      // Emit event
      swiper.emit('scroll', e);

      // Stop autoplay
      if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();
      // Return page scroll on edge positions
      if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
    }

    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
    return false;
  },
  enable() {
    const swiper = this;
    if (!Mousewheel.event) return false;
    if (swiper.mousewheel.enabled) return false;
    let target = swiper.$el;
    if (swiper.params.mousewheel.eventsTarged !== 'container') {
      target = $(swiper.params.mousewheel.eventsTarged);
    }
    target.on('mouseenter', swiper.mousewheel.handleMouseEnter);
    target.on('mouseleave', swiper.mousewheel.handleMouseLeave);
    target.on(Mousewheel.event, swiper.mousewheel.handle);
    swiper.mousewheel.enabled = true;
    return true;
  },
  disable() {
    const swiper = this;
    if (!Mousewheel.event) return false;
    if (!swiper.mousewheel.enabled) return false;
    let target = swiper.$el;
    if (swiper.params.mousewheel.eventsTarged !== 'container') {
      target = $(swiper.params.mousewheel.eventsTarged);
    }
    target.off(Mousewheel.event, swiper.mousewheel.handle);
    swiper.mousewheel.enabled = false;
    return true;
  },
};

var Mousewheel$1 = {
  name: 'mousewheel',
  params: {
    mousewheel: {
      enabled: false,
      releaseOnEdges: false,
      invert: false,
      forceToAxis: false,
      sensitivity: 1,
      eventsTarged: 'container',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      mousewheel: {
        enabled: false,
        enable: Mousewheel.enable.bind(swiper),
        disable: Mousewheel.disable.bind(swiper),
        handle: Mousewheel.handle.bind(swiper),
        handleMouseEnter: Mousewheel.handleMouseEnter.bind(swiper),
        handleMouseLeave: Mousewheel.handleMouseLeave.bind(swiper),
        lastScrollTime: Utils.now(),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();
    },
    destroy() {
      const swiper = this;
      if (swiper.mousewheel.enabled) swiper.mousewheel.disable();
    },
  },
};

const Navigation = {
  update() {
    // Update Navigation Buttons
    const swiper = this;
    const params = swiper.params.navigation;

    if (swiper.params.loop) return;
    const { $nextEl, $prevEl } = swiper.navigation;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        $prevEl.addClass(params.disabledClass);
      } else {
        $prevEl.removeClass(params.disabledClass);
      }
      $prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    }
    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        $nextEl.addClass(params.disabledClass);
      } else {
        $nextEl.removeClass(params.disabledClass);
      }
      $nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    }
  },
  onPrevClick(e) {
    const swiper = this;
    e.preventDefault();
    if (swiper.isBeginning && !swiper.params.loop) return;
    swiper.slidePrev();
  },
  onNextClick(e) {
    const swiper = this;
    e.preventDefault();
    if (swiper.isEnd && !swiper.params.loop) return;
    swiper.slideNext();
  },
  init() {
    const swiper = this;
    const params = swiper.params.navigation;
    if (!(params.nextEl || params.prevEl)) return;

    let $nextEl;
    let $prevEl;
    if (params.nextEl) {
      $nextEl = $(params.nextEl);
      if (
        swiper.params.uniqueNavElements
        && typeof params.nextEl === 'string'
        && $nextEl.length > 1
        && swiper.$el.find(params.nextEl).length === 1
      ) {
        $nextEl = swiper.$el.find(params.nextEl);
      }
    }
    if (params.prevEl) {
      $prevEl = $(params.prevEl);
      if (
        swiper.params.uniqueNavElements
        && typeof params.prevEl === 'string'
        && $prevEl.length > 1
        && swiper.$el.find(params.prevEl).length === 1
      ) {
        $prevEl = swiper.$el.find(params.prevEl);
      }
    }

    if ($nextEl && $nextEl.length > 0) {
      $nextEl.on('click', swiper.navigation.onNextClick);
    }
    if ($prevEl && $prevEl.length > 0) {
      $prevEl.on('click', swiper.navigation.onPrevClick);
    }

    Utils.extend(swiper.navigation, {
      $nextEl,
      nextEl: $nextEl && $nextEl[0],
      $prevEl,
      prevEl: $prevEl && $prevEl[0],
    });
  },
  destroy() {
    const swiper = this;
    const { $nextEl, $prevEl } = swiper.navigation;
    if ($nextEl && $nextEl.length) {
      $nextEl.off('click', swiper.navigation.onNextClick);
      $nextEl.removeClass(swiper.params.navigation.disabledClass);
    }
    if ($prevEl && $prevEl.length) {
      $prevEl.off('click', swiper.navigation.onPrevClick);
      $prevEl.removeClass(swiper.params.navigation.disabledClass);
    }
  },
};

var Navigation$1 = {
  name: 'navigation',
  params: {
    navigation: {
      nextEl: null,
      prevEl: null,

      hideOnClick: false,
      disabledClass: 'swiper-button-disabled',
      hiddenClass: 'swiper-button-hidden',
      lockClass: 'swiper-button-lock',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      navigation: {
        init: Navigation.init.bind(swiper),
        update: Navigation.update.bind(swiper),
        destroy: Navigation.destroy.bind(swiper),
        onNextClick: Navigation.onNextClick.bind(swiper),
        onPrevClick: Navigation.onPrevClick.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.navigation.init();
      swiper.navigation.update();
    },
    toEdge() {
      const swiper = this;
      swiper.navigation.update();
    },
    fromEdge() {
      const swiper = this;
      swiper.navigation.update();
    },
    destroy() {
      const swiper = this;
      swiper.navigation.destroy();
    },
    click(e) {
      const swiper = this;
      const { $nextEl, $prevEl } = swiper.navigation;
      if (
        swiper.params.navigation.hideOnClick
        && !$(e.target).is($prevEl)
        && !$(e.target).is($nextEl)
      ) {
        let isHidden;
        if ($nextEl) {
          isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
        } else if ($prevEl) {
          isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
        }
        if (isHidden === true) {
          swiper.emit('navigationShow', swiper);
        } else {
          swiper.emit('navigationHide', swiper);
        }
        if ($nextEl) {
          $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
        }
        if ($prevEl) {
          $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
        }
      }
    },
  },
};

const Pagination = {
  update() {
    // Render || Update Pagination bullets/items
    const swiper = this;
    const rtl = swiper.rtl;
    const params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const $el = swiper.pagination.$el;
    // Current/Total
    let current;
    const total = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
    if (swiper.params.loop) {
      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
      if (current > slidesLength - 1 - (swiper.loopedSlides * 2)) {
        current -= (slidesLength - (swiper.loopedSlides * 2));
      }
      if (current > total - 1) current -= total;
      if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
    } else if (typeof swiper.snapIndex !== 'undefined') {
      current = swiper.snapIndex;
    } else {
      current = swiper.activeIndex || 0;
    }
    // Types
    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      const bullets = swiper.pagination.bullets;
      let firstIndex;
      let lastIndex;
      let midIndex;
      if (params.dynamicBullets) {
        swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
        $el.css(swiper.isHorizontal() ? 'width' : 'height', `${swiper.pagination.bulletSize * (params.dynamicMainBullets + 4)}px`);
        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
          swiper.pagination.dynamicBulletIndex += (current - swiper.previousIndex);
          if (swiper.pagination.dynamicBulletIndex > (params.dynamicMainBullets - 1)) {
            swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
          } else if (swiper.pagination.dynamicBulletIndex < 0) {
            swiper.pagination.dynamicBulletIndex = 0;
          }
        }
        firstIndex = current - swiper.pagination.dynamicBulletIndex;
        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
        midIndex = (lastIndex + firstIndex) / 2;
      }
      bullets.removeClass(`${params.bulletActiveClass} ${params.bulletActiveClass}-next ${params.bulletActiveClass}-next-next ${params.bulletActiveClass}-prev ${params.bulletActiveClass}-prev-prev ${params.bulletActiveClass}-main`);
      if ($el.length > 1) {
        bullets.each((index, bullet) => {
          const $bullet = $(bullet);
          const bulletIndex = $bullet.index();
          if (bulletIndex === current) {
            $bullet.addClass(params.bulletActiveClass);
          }
          if (params.dynamicBullets) {
            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
              $bullet.addClass(`${params.bulletActiveClass}-main`);
            }
            if (bulletIndex === firstIndex) {
              $bullet
                .prev()
                .addClass(`${params.bulletActiveClass}-prev`)
                .prev()
                .addClass(`${params.bulletActiveClass}-prev-prev`);
            }
            if (bulletIndex === lastIndex) {
              $bullet
                .next()
                .addClass(`${params.bulletActiveClass}-next`)
                .next()
                .addClass(`${params.bulletActiveClass}-next-next`);
            }
          }
        });
      } else {
        const $bullet = bullets.eq(current);
        $bullet.addClass(params.bulletActiveClass);
        if (params.dynamicBullets) {
          const $firstDisplayedBullet = bullets.eq(firstIndex);
          const $lastDisplayedBullet = bullets.eq(lastIndex);
          for (let i = firstIndex; i <= lastIndex; i += 1) {
            bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
          }
          $firstDisplayedBullet
            .prev()
            .addClass(`${params.bulletActiveClass}-prev`)
            .prev()
            .addClass(`${params.bulletActiveClass}-prev-prev`);
          $lastDisplayedBullet
            .next()
            .addClass(`${params.bulletActiveClass}-next`)
            .next()
            .addClass(`${params.bulletActiveClass}-next-next`);
        }
      }
      if (params.dynamicBullets) {
        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
        const bulletsOffset = (((swiper.pagination.bulletSize * dynamicBulletsLength) - (swiper.pagination.bulletSize)) / 2) - (midIndex * swiper.pagination.bulletSize);
        const offsetProp = rtl ? 'right' : 'left';
        bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
      }
    }
    if (params.type === 'fraction') {
      $el.find(`.${params.currentClass}`).text(params.formatFractionCurrent(current + 1));
      $el.find(`.${params.totalClass}`).text(params.formatFractionTotal(total));
    }
    if (params.type === 'progressbar') {
      let progressbarDirection;
      if (params.progressbarOpposite) {
        progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
      } else {
        progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
      }
      const scale = (current + 1) / total;
      let scaleX = 1;
      let scaleY = 1;
      if (progressbarDirection === 'horizontal') {
        scaleX = scale;
      } else {
        scaleY = scale;
      }
      $el.find(`.${params.progressbarFillClass}`).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
    }
    if (params.type === 'custom' && params.renderCustom) {
      $el.html(params.renderCustom(swiper, current + 1, total));
      swiper.emit('paginationRender', swiper, $el[0]);
    } else {
      swiper.emit('paginationUpdate', swiper, $el[0]);
    }
    $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
  },
  render() {
    // Render Container
    const swiper = this;
    const params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;

    const $el = swiper.pagination.$el;
    let paginationHTML = '';
    if (params.type === 'bullets') {
      const numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
      for (let i = 0; i < numberOfBullets; i += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
        } else {
          paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
        }
      }
      $el.html(paginationHTML);
      swiper.pagination.bullets = $el.find(`.${params.bulletClass}`);
    }
    if (params.type === 'fraction') {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML = `<span class="${params.currentClass}"></span>`
        + ' / '
        + `<span class="${params.totalClass}"></span>`;
      }
      $el.html(paginationHTML);
    }
    if (params.type === 'progressbar') {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
      }
      $el.html(paginationHTML);
    }
    if (params.type !== 'custom') {
      swiper.emit('paginationRender', swiper.pagination.$el[0]);
    }
  },
  init() {
    const swiper = this;
    const params = swiper.params.pagination;
    if (!params.el) return;

    let $el = $(params.el);
    if ($el.length === 0) return;

    if (
      swiper.params.uniqueNavElements
      && typeof params.el === 'string'
      && $el.length > 1
      && swiper.$el.find(params.el).length === 1
    ) {
      $el = swiper.$el.find(params.el);
    }

    if (params.type === 'bullets' && params.clickable) {
      $el.addClass(params.clickableClass);
    }

    $el.addClass(params.modifierClass + params.type);

    if (params.type === 'bullets' && params.dynamicBullets) {
      $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
      swiper.pagination.dynamicBulletIndex = 0;
      if (params.dynamicMainBullets < 1) {
        params.dynamicMainBullets = 1;
      }
    }
    if (params.type === 'progressbar' && params.progressbarOpposite) {
      $el.addClass(params.progressbarOppositeClass);
    }

    if (params.clickable) {
      $el.on('click', `.${params.bulletClass}`, function onClick(e) {
        e.preventDefault();
        let index = $(this).index() * swiper.params.slidesPerGroup;
        if (swiper.params.loop) index += swiper.loopedSlides;
        swiper.slideTo(index);
      });
    }

    Utils.extend(swiper.pagination, {
      $el,
      el: $el[0],
    });
  },
  destroy() {
    const swiper = this;
    const params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    const $el = swiper.pagination.$el;

    $el.removeClass(params.hiddenClass);
    $el.removeClass(params.modifierClass + params.type);
    if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);
    if (params.clickable) {
      $el.off('click', `.${params.bulletClass}`);
    }
  },
};

var Pagination$1 = {
  name: 'pagination',
  params: {
    pagination: {
      el: null,
      bulletElement: 'span',
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: false,
      type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: false,
      dynamicMainBullets: 1,
      formatFractionCurrent: (number) => number,
      formatFractionTotal: (number) => number,
      bulletClass: 'swiper-pagination-bullet',
      bulletActiveClass: 'swiper-pagination-bullet-active',
      modifierClass: 'swiper-pagination-', // NEW
      currentClass: 'swiper-pagination-current',
      totalClass: 'swiper-pagination-total',
      hiddenClass: 'swiper-pagination-hidden',
      progressbarFillClass: 'swiper-pagination-progressbar-fill',
      progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
      clickableClass: 'swiper-pagination-clickable', // NEW
      lockClass: 'swiper-pagination-lock',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      pagination: {
        init: Pagination.init.bind(swiper),
        render: Pagination.render.bind(swiper),
        update: Pagination.update.bind(swiper),
        destroy: Pagination.destroy.bind(swiper),
        dynamicBulletIndex: 0,
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.pagination.init();
      swiper.pagination.render();
      swiper.pagination.update();
    },
    activeIndexChange() {
      const swiper = this;
      if (swiper.params.loop) {
        swiper.pagination.update();
      } else if (typeof swiper.snapIndex === 'undefined') {
        swiper.pagination.update();
      }
    },
    snapIndexChange() {
      const swiper = this;
      if (!swiper.params.loop) {
        swiper.pagination.update();
      }
    },
    slidesLengthChange() {
      const swiper = this;
      if (swiper.params.loop) {
        swiper.pagination.render();
        swiper.pagination.update();
      }
    },
    snapGridLengthChange() {
      const swiper = this;
      if (!swiper.params.loop) {
        swiper.pagination.render();
        swiper.pagination.update();
      }
    },
    destroy() {
      const swiper = this;
      swiper.pagination.destroy();
    },
    click(e) {
      const swiper = this;
      if (
        swiper.params.pagination.el
        && swiper.params.pagination.hideOnClick
        && swiper.pagination.$el.length > 0
        && !$(e.target).hasClass(swiper.params.pagination.bulletClass)
      ) {
        const isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);
        if (isHidden === true) {
          swiper.emit('paginationShow', swiper);
        } else {
          swiper.emit('paginationHide', swiper);
        }
        swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
      }
    },
  },
};

const Scrollbar = {
  setTranslate() {
    const swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    const { scrollbar, rtlTranslate: rtl, progress } = swiper;
    const {
      dragSize, trackSize, $dragEl, $el,
    } = scrollbar;
    const params = swiper.params.scrollbar;

    let newSize = dragSize;
    let newPos = (trackSize - dragSize) * progress;
    if (rtl) {
      newPos = -newPos;
      if (newPos > 0) {
        newSize = dragSize - newPos;
        newPos = 0;
      } else if (-newPos + dragSize > trackSize) {
        newSize = trackSize + newPos;
      }
    } else if (newPos < 0) {
      newSize = dragSize + newPos;
      newPos = 0;
    } else if (newPos + dragSize > trackSize) {
      newSize = trackSize - newPos;
    }
    if (swiper.isHorizontal()) {
      if (swiper_esm_bundle_Support.transforms3d) {
        $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
      } else {
        $dragEl.transform(`translateX(${newPos}px)`);
      }
      $dragEl[0].style.width = `${newSize}px`;
    } else {
      if (swiper_esm_bundle_Support.transforms3d) {
        $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
      } else {
        $dragEl.transform(`translateY(${newPos}px)`);
      }
      $dragEl[0].style.height = `${newSize}px`;
    }
    if (params.hide) {
      clearTimeout(swiper.scrollbar.timeout);
      $el[0].style.opacity = 1;
      swiper.scrollbar.timeout = setTimeout(() => {
        $el[0].style.opacity = 0;
        $el.transition(400);
      }, 1000);
    }
  },
  setTransition(duration) {
    const swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    swiper.scrollbar.$dragEl.transition(duration);
  },
  updateSize() {
    const swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;

    const { scrollbar } = swiper;
    const { $dragEl, $el } = scrollbar;

    $dragEl[0].style.width = '';
    $dragEl[0].style.height = '';
    const trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;

    const divider = swiper.size / swiper.virtualSize;
    const moveDivider = divider * (trackSize / swiper.size);
    let dragSize;
    if (swiper.params.scrollbar.dragSize === 'auto') {
      dragSize = trackSize * divider;
    } else {
      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
    }

    if (swiper.isHorizontal()) {
      $dragEl[0].style.width = `${dragSize}px`;
    } else {
      $dragEl[0].style.height = `${dragSize}px`;
    }

    if (divider >= 1) {
      $el[0].style.display = 'none';
    } else {
      $el[0].style.display = '';
    }
    if (swiper.params.scrollbar.hide) {
      $el[0].style.opacity = 0;
    }
    Utils.extend(scrollbar, {
      trackSize,
      divider,
      moveDivider,
      dragSize,
    });
    scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
  },
  getPointerPosition(e) {
    const swiper = this;
    if (swiper.isHorizontal()) {
      return ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageX : e.pageX || e.clientX);
    }
    return ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageY : e.pageY || e.clientY);
  },
  setDragPosition(e) {
    const swiper = this;
    const { scrollbar, rtlTranslate: rtl } = swiper;
    const {
      $el,
      dragSize,
      trackSize,
      dragStartPos,
    } = scrollbar;

    let positionRatio;
    positionRatio = ((scrollbar.getPointerPosition(e)) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top']
      - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
    positionRatio = Math.max(Math.min(positionRatio, 1), 0);
    if (rtl) {
      positionRatio = 1 - positionRatio;
    }

    const position = swiper.minTranslate() + ((swiper.maxTranslate() - swiper.minTranslate()) * positionRatio);

    swiper.updateProgress(position);
    swiper.setTranslate(position);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  },
  onDragStart(e) {
    const swiper = this;
    const params = swiper.params.scrollbar;
    const { scrollbar, $wrapperEl } = swiper;
    const { $el, $dragEl } = scrollbar;
    swiper.scrollbar.isTouched = true;
    swiper.scrollbar.dragStartPos = (e.target === $dragEl[0] || e.target === $dragEl)
      ? scrollbar.getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
    e.preventDefault();
    e.stopPropagation();

    $wrapperEl.transition(100);
    $dragEl.transition(100);
    scrollbar.setDragPosition(e);

    clearTimeout(swiper.scrollbar.dragTimeout);

    $el.transition(0);
    if (params.hide) {
      $el.css('opacity', 1);
    }
    swiper.emit('scrollbarDragStart', e);
  },
  onDragMove(e) {
    const swiper = this;
    const { scrollbar, $wrapperEl } = swiper;
    const { $el, $dragEl } = scrollbar;

    if (!swiper.scrollbar.isTouched) return;
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
    scrollbar.setDragPosition(e);
    $wrapperEl.transition(0);
    $el.transition(0);
    $dragEl.transition(0);
    swiper.emit('scrollbarDragMove', e);
  },
  onDragEnd(e) {
    const swiper = this;

    const params = swiper.params.scrollbar;
    const { scrollbar } = swiper;
    const { $el } = scrollbar;

    if (!swiper.scrollbar.isTouched) return;
    swiper.scrollbar.isTouched = false;
    if (params.hide) {
      clearTimeout(swiper.scrollbar.dragTimeout);
      swiper.scrollbar.dragTimeout = Utils.nextTick(() => {
        $el.css('opacity', 0);
        $el.transition(400);
      }, 1000);
    }
    swiper.emit('scrollbarDragEnd', e);
    if (params.snapOnRelease) {
      swiper.slideToClosest();
    }
  },
  enableDraggable() {
    const swiper = this;
    if (!swiper.params.scrollbar.el) return;
    const {
      scrollbar, touchEventsTouch, touchEventsDesktop, params,
    } = swiper;
    const $el = scrollbar.$el;
    const target = $el[0];
    const activeListener = swiper_esm_bundle_Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;
    const passiveListener = swiper_esm_bundle_Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
    if (!swiper_esm_bundle_Support.touch) {
      target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
      ssr_window_esm_doc.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
      ssr_window_esm_doc.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
    } else {
      target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
      target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
      target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
    }
  },
  disableDraggable() {
    const swiper = this;
    if (!swiper.params.scrollbar.el) return;
    const {
      scrollbar, touchEventsTouch, touchEventsDesktop, params,
    } = swiper;
    const $el = scrollbar.$el;
    const target = $el[0];
    const activeListener = swiper_esm_bundle_Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;
    const passiveListener = swiper_esm_bundle_Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
    if (!swiper_esm_bundle_Support.touch) {
      target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
      ssr_window_esm_doc.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
      ssr_window_esm_doc.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
    } else {
      target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
      target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
      target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
    }
  },
  init() {
    const swiper = this;
    if (!swiper.params.scrollbar.el) return;
    const { scrollbar, $el: $swiperEl } = swiper;
    const params = swiper.params.scrollbar;

    let $el = $(params.el);
    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
      $el = $swiperEl.find(params.el);
    }

    let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);
    if ($dragEl.length === 0) {
      $dragEl = $(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
      $el.append($dragEl);
    }

    Utils.extend(scrollbar, {
      $el,
      el: $el[0],
      $dragEl,
      dragEl: $dragEl[0],
    });

    if (params.draggable) {
      scrollbar.enableDraggable();
    }
  },
  destroy() {
    const swiper = this;
    swiper.scrollbar.disableDraggable();
  },
};

var Scrollbar$1 = {
  name: 'scrollbar',
  params: {
    scrollbar: {
      el: null,
      dragSize: 'auto',
      hide: false,
      draggable: false,
      snapOnRelease: true,
      lockClass: 'swiper-scrollbar-lock',
      dragClass: 'swiper-scrollbar-drag',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      scrollbar: {
        init: Scrollbar.init.bind(swiper),
        destroy: Scrollbar.destroy.bind(swiper),
        updateSize: Scrollbar.updateSize.bind(swiper),
        setTranslate: Scrollbar.setTranslate.bind(swiper),
        setTransition: Scrollbar.setTransition.bind(swiper),
        enableDraggable: Scrollbar.enableDraggable.bind(swiper),
        disableDraggable: Scrollbar.disableDraggable.bind(swiper),
        setDragPosition: Scrollbar.setDragPosition.bind(swiper),
        getPointerPosition: Scrollbar.getPointerPosition.bind(swiper),
        onDragStart: Scrollbar.onDragStart.bind(swiper),
        onDragMove: Scrollbar.onDragMove.bind(swiper),
        onDragEnd: Scrollbar.onDragEnd.bind(swiper),
        isTouched: false,
        timeout: null,
        dragTimeout: null,
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.scrollbar.init();
      swiper.scrollbar.updateSize();
      swiper.scrollbar.setTranslate();
    },
    update() {
      const swiper = this;
      swiper.scrollbar.updateSize();
    },
    resize() {
      const swiper = this;
      swiper.scrollbar.updateSize();
    },
    observerUpdate() {
      const swiper = this;
      swiper.scrollbar.updateSize();
    },
    setTranslate() {
      const swiper = this;
      swiper.scrollbar.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      swiper.scrollbar.setTransition(duration);
    },
    destroy() {
      const swiper = this;
      swiper.scrollbar.destroy();
    },
  },
};

const Parallax = {
  setTransform(el, progress) {
    const swiper = this;
    const { rtl } = swiper;

    const $el = $(el);
    const rtlFactor = rtl ? -1 : 1;

    const p = $el.attr('data-swiper-parallax') || '0';
    let x = $el.attr('data-swiper-parallax-x');
    let y = $el.attr('data-swiper-parallax-y');
    const scale = $el.attr('data-swiper-parallax-scale');
    const opacity = $el.attr('data-swiper-parallax-opacity');

    if (x || y) {
      x = x || '0';
      y = y || '0';
    } else if (swiper.isHorizontal()) {
      x = p;
      y = '0';
    } else {
      y = p;
      x = '0';
    }

    if ((x).indexOf('%') >= 0) {
      x = `${parseInt(x, 10) * progress * rtlFactor}%`;
    } else {
      x = `${x * progress * rtlFactor}px`;
    }
    if ((y).indexOf('%') >= 0) {
      y = `${parseInt(y, 10) * progress}%`;
    } else {
      y = `${y * progress}px`;
    }

    if (typeof opacity !== 'undefined' && opacity !== null) {
      const currentOpacity = opacity - ((opacity - 1) * (1 - Math.abs(progress)));
      $el[0].style.opacity = currentOpacity;
    }
    if (typeof scale === 'undefined' || scale === null) {
      $el.transform(`translate3d(${x}, ${y}, 0px)`);
    } else {
      const currentScale = scale - ((scale - 1) * (1 - Math.abs(progress)));
      $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
    }
  },
  setTranslate() {
    const swiper = this;
    const {
      $el, slides, progress, snapGrid,
    } = swiper;
    $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')
      .each((index, el) => {
        swiper.parallax.setTransform(el, progress);
      });
    slides.each((slideIndex, slideEl) => {
      let slideProgress = slideEl.progress;
      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
        slideProgress += Math.ceil(slideIndex / 2) - (progress * (snapGrid.length - 1));
      }
      slideProgress = Math.min(Math.max(slideProgress, -1), 1);
      $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')
        .each((index, el) => {
          swiper.parallax.setTransform(el, slideProgress);
        });
    });
  },
  setTransition(duration = this.params.speed) {
    const swiper = this;
    const { $el } = swiper;
    $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')
      .each((index, parallaxEl) => {
        const $parallaxEl = $(parallaxEl);
        let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
        if (duration === 0) parallaxDuration = 0;
        $parallaxEl.transition(parallaxDuration);
      });
  },
};

var Parallax$1 = {
  name: 'parallax',
  params: {
    parallax: {
      enabled: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      parallax: {
        setTransform: Parallax.setTransform.bind(swiper),
        setTranslate: Parallax.setTranslate.bind(swiper),
        setTransition: Parallax.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (!swiper.params.parallax.enabled) return;
      swiper.params.watchSlidesProgress = true;
      swiper.originalParams.watchSlidesProgress = true;
    },
    init() {
      const swiper = this;
      if (!swiper.params.parallax.enabled) return;
      swiper.parallax.setTranslate();
    },
    setTranslate() {
      const swiper = this;
      if (!swiper.params.parallax.enabled) return;
      swiper.parallax.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (!swiper.params.parallax.enabled) return;
      swiper.parallax.setTransition(duration);
    },
  },
};

const Zoom = {
  // Calc Scale From Multi-touches
  getDistanceBetweenTouches(e) {
    if (e.targetTouches.length < 2) return 1;
    const x1 = e.targetTouches[0].pageX;
    const y1 = e.targetTouches[0].pageY;
    const x2 = e.targetTouches[1].pageX;
    const y2 = e.targetTouches[1].pageY;
    const distance = Math.sqrt(((x2 - x1) ** 2) + ((y2 - y1) ** 2));
    return distance;
  },
  // Events
  onGestureStart(e) {
    const swiper = this;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    zoom.fakeGestureTouched = false;
    zoom.fakeGestureMoved = false;
    if (!swiper_esm_bundle_Support.gestures) {
      if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {
        return;
      }
      zoom.fakeGestureTouched = true;
      gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
    }
    if (!gesture.$slideEl || !gesture.$slideEl.length) {
      gesture.$slideEl = $(e.target).closest('.swiper-slide');
      if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
      gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
      if (gesture.$imageWrapEl.length === 0) {
        gesture.$imageEl = undefined;
        return;
      }
    }
    gesture.$imageEl.transition(0);
    swiper.zoom.isScaling = true;
  },
  onGestureChange(e) {
    const swiper = this;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    if (!swiper_esm_bundle_Support.gestures) {
      if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {
        return;
      }
      zoom.fakeGestureMoved = true;
      gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (swiper_esm_bundle_Support.gestures) {
      zoom.scale = e.scale * zoom.currentScale;
    } else {
      zoom.scale = (gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;
    }
    if (zoom.scale > gesture.maxRatio) {
      zoom.scale = (gesture.maxRatio - 1) + (((zoom.scale - gesture.maxRatio) + 1) ** 0.5);
    }
    if (zoom.scale < params.minRatio) {
      zoom.scale = (params.minRatio + 1) - (((params.minRatio - zoom.scale) + 1) ** 0.5);
    }
    gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);
  },
  onGestureEnd(e) {
    const swiper = this;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    if (!swiper_esm_bundle_Support.gestures) {
      if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
        return;
      }
      if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2 && !swiper_esm_bundle_Device.android)) {
        return;
      }
      zoom.fakeGestureTouched = false;
      zoom.fakeGestureMoved = false;
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
    gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
    zoom.currentScale = zoom.scale;
    zoom.isScaling = false;
    if (zoom.scale === 1) gesture.$slideEl = undefined;
  },
  onTouchStart(e) {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture, image } = zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (image.isTouched) return;
    if (swiper_esm_bundle_Device.android) e.preventDefault();
    image.isTouched = true;
    image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  },
  onTouchMove(e) {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture, image, velocity } = zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    swiper.allowClick = false;
    if (!image.isTouched || !gesture.$slideEl) return;

    if (!image.isMoved) {
      image.width = gesture.$imageEl[0].offsetWidth;
      image.height = gesture.$imageEl[0].offsetHeight;
      image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
      image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
      gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
      gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
      gesture.$imageWrapEl.transition(0);
      if (swiper.rtl) {
        image.startX = -image.startX;
        image.startY = -image.startY;
      }
    }
    // Define if we need image drag
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;

    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;

    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
    image.maxX = -image.minX;
    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
    image.maxY = -image.minY;

    image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
    image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

    if (!image.isMoved && !zoom.isScaling) {
      if (
        swiper.isHorizontal()
        && (
          (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x)
          || (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)
        )
      ) {
        image.isTouched = false;
        return;
      } if (
        !swiper.isHorizontal()
        && (
          (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y)
          || (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)
        )
      ) {
        image.isTouched = false;
        return;
      }
    }
    e.preventDefault();
    e.stopPropagation();

    image.isMoved = true;
    image.currentX = (image.touchesCurrent.x - image.touchesStart.x) + image.startX;
    image.currentY = (image.touchesCurrent.y - image.touchesStart.y) + image.startY;

    if (image.currentX < image.minX) {
      image.currentX = (image.minX + 1) - (((image.minX - image.currentX) + 1) ** 0.8);
    }
    if (image.currentX > image.maxX) {
      image.currentX = (image.maxX - 1) + (((image.currentX - image.maxX) + 1) ** 0.8);
    }

    if (image.currentY < image.minY) {
      image.currentY = (image.minY + 1) - (((image.minY - image.currentY) + 1) ** 0.8);
    }
    if (image.currentY > image.maxY) {
      image.currentY = (image.maxY - 1) + (((image.currentY - image.maxY) + 1) ** 0.8);
    }

    // Velocity
    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
    if (!velocity.prevTime) velocity.prevTime = Date.now();
    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
    velocity.prevPositionX = image.touchesCurrent.x;
    velocity.prevPositionY = image.touchesCurrent.y;
    velocity.prevTime = Date.now();

    gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
  },
  onTouchEnd() {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture, image, velocity } = zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (!image.isTouched || !image.isMoved) {
      image.isTouched = false;
      image.isMoved = false;
      return;
    }
    image.isTouched = false;
    image.isMoved = false;
    let momentumDurationX = 300;
    let momentumDurationY = 300;
    const momentumDistanceX = velocity.x * momentumDurationX;
    const newPositionX = image.currentX + momentumDistanceX;
    const momentumDistanceY = velocity.y * momentumDurationY;
    const newPositionY = image.currentY + momentumDistanceY;

    // Fix duration
    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);

    image.currentX = newPositionX;
    image.currentY = newPositionY;

    // Define if we need image drag
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;
    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
    image.maxX = -image.minX;
    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
    image.maxY = -image.minY;
    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);

    gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
  },
  onTransitionEnd() {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
      gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
      gesture.$imageWrapEl.transform('translate3d(0,0,0)');

      zoom.scale = 1;
      zoom.currentScale = 1;

      gesture.$slideEl = undefined;
      gesture.$imageEl = undefined;
      gesture.$imageWrapEl = undefined;
    }
  },
  // Toggle Zoom
  toggle(e) {
    const swiper = this;
    const zoom = swiper.zoom;

    if (zoom.scale && zoom.scale !== 1) {
      // Zoom Out
      zoom.out();
    } else {
      // Zoom In
      zoom.in(e);
    }
  },
  in(e) {
    const swiper = this;

    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    const { gesture, image } = zoom;

    if (!gesture.$slideEl) {
      gesture.$slideEl = swiper.clickedSlide ? $(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

    gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);

    let touchX;
    let touchY;
    let offsetX;
    let offsetY;
    let diffX;
    let diffY;
    let translateX;
    let translateY;
    let imageWidth;
    let imageHeight;
    let scaledWidth;
    let scaledHeight;
    let translateMinX;
    let translateMinY;
    let translateMaxX;
    let translateMaxY;
    let slideWidth;
    let slideHeight;

    if (typeof image.touchesStart.x === 'undefined' && e) {
      touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
      touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
    } else {
      touchX = image.touchesStart.x;
      touchY = image.touchesStart.y;
    }

    zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
    zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
    if (e) {
      slideWidth = gesture.$slideEl[0].offsetWidth;
      slideHeight = gesture.$slideEl[0].offsetHeight;
      offsetX = gesture.$slideEl.offset().left;
      offsetY = gesture.$slideEl.offset().top;
      diffX = (offsetX + (slideWidth / 2)) - touchX;
      diffY = (offsetY + (slideHeight / 2)) - touchY;

      imageWidth = gesture.$imageEl[0].offsetWidth;
      imageHeight = gesture.$imageEl[0].offsetHeight;
      scaledWidth = imageWidth * zoom.scale;
      scaledHeight = imageHeight * zoom.scale;

      translateMinX = Math.min(((slideWidth / 2) - (scaledWidth / 2)), 0);
      translateMinY = Math.min(((slideHeight / 2) - (scaledHeight / 2)), 0);
      translateMaxX = -translateMinX;
      translateMaxY = -translateMinY;

      translateX = diffX * zoom.scale;
      translateY = diffY * zoom.scale;

      if (translateX < translateMinX) {
        translateX = translateMinX;
      }
      if (translateX > translateMaxX) {
        translateX = translateMaxX;
      }

      if (translateY < translateMinY) {
        translateY = translateMinY;
      }
      if (translateY > translateMaxY) {
        translateY = translateMaxY;
      }
    } else {
      translateX = 0;
      translateY = 0;
    }
    gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);
    gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
  },
  out() {
    const swiper = this;

    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    const { gesture } = zoom;

    if (!gesture.$slideEl) {
      gesture.$slideEl = swiper.clickedSlide ? $(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

    zoom.scale = 1;
    zoom.currentScale = 1;
    gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
    gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
    gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);
    gesture.$slideEl = undefined;
  },
  // Attach/Detach Events
  enable() {
    const swiper = this;
    const zoom = swiper.zoom;
    if (zoom.enabled) return;
    zoom.enabled = true;

    const passiveListener = swiper.touchEvents.start === 'touchstart' && swiper_esm_bundle_Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;

    // Scale image
    if (swiper_esm_bundle_Support.gestures) {
      swiper.$wrapperEl.on('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.on('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);
      swiper.$wrapperEl.on('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);
    } else if (swiper.touchEvents.start === 'touchstart') {
      swiper.$wrapperEl.on(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.on(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);
      swiper.$wrapperEl.on(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);
    }

    // Move image
    swiper.$wrapperEl.on(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove);
  },
  disable() {
    const swiper = this;
    const zoom = swiper.zoom;
    if (!zoom.enabled) return;

    swiper.zoom.enabled = false;

    const passiveListener = swiper.touchEvents.start === 'touchstart' && swiper_esm_bundle_Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;

    // Scale image
    if (swiper_esm_bundle_Support.gestures) {
      swiper.$wrapperEl.off('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.off('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);
      swiper.$wrapperEl.off('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);
    } else if (swiper.touchEvents.start === 'touchstart') {
      swiper.$wrapperEl.off(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.off(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);
      swiper.$wrapperEl.off(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);
    }

    // Move image
    swiper.$wrapperEl.off(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove);
  },
};

var Zoom$1 = {
  name: 'zoom',
  params: {
    zoom: {
      enabled: false,
      maxRatio: 3,
      minRatio: 1,
      toggle: true,
      containerClass: 'swiper-zoom-container',
      zoomedSlideClass: 'swiper-slide-zoomed',
    },
  },
  create() {
    const swiper = this;
    const zoom = {
      enabled: false,
      scale: 1,
      currentScale: 1,
      isScaling: false,
      gesture: {
        $slideEl: undefined,
        slideWidth: undefined,
        slideHeight: undefined,
        $imageEl: undefined,
        $imageWrapEl: undefined,
        maxRatio: 3,
      },
      image: {
        isTouched: undefined,
        isMoved: undefined,
        currentX: undefined,
        currentY: undefined,
        minX: undefined,
        minY: undefined,
        maxX: undefined,
        maxY: undefined,
        width: undefined,
        height: undefined,
        startX: undefined,
        startY: undefined,
        touchesStart: {},
        touchesCurrent: {},
      },
      velocity: {
        x: undefined,
        y: undefined,
        prevPositionX: undefined,
        prevPositionY: undefined,
        prevTime: undefined,
      },
    };

    ('onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out').split(' ').forEach((methodName) => {
      zoom[methodName] = Zoom[methodName].bind(swiper);
    });
    Utils.extend(swiper, {
      zoom,
    });

    let scale = 1;
    Object.defineProperty(swiper.zoom, 'scale', {
      get() {
        return scale;
      },
      set(value) {
        if (scale !== value) {
          const imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : undefined;
          const slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : undefined;
          swiper.emit('zoomChange', value, imageEl, slideEl);
        }
        scale = value;
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.zoom.enabled) {
        swiper.zoom.enable();
      }
    },
    destroy() {
      const swiper = this;
      swiper.zoom.disable();
    },
    touchStart(e) {
      const swiper = this;
      if (!swiper.zoom.enabled) return;
      swiper.zoom.onTouchStart(e);
    },
    touchEnd(e) {
      const swiper = this;
      if (!swiper.zoom.enabled) return;
      swiper.zoom.onTouchEnd(e);
    },
    doubleTap(e) {
      const swiper = this;
      if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
        swiper.zoom.toggle(e);
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
        swiper.zoom.onTransitionEnd();
      }
    },
  },
};

const Lazy = {
  loadInSlide(index, loadInDuplicate = true) {
    const swiper = this;
    const params = swiper.params.lazy;
    if (typeof index === 'undefined') return;
    if (swiper.slides.length === 0) return;
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

    const $slideEl = isVirtual
      ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index="${index}"]`)
      : swiper.slides.eq(index);

    let $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);
    if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
      $images = $images.add($slideEl[0]);
    }
    if ($images.length === 0) return;

    $images.each((imageIndex, imageEl) => {
      const $imageEl = $(imageEl);
      $imageEl.addClass(params.loadingClass);

      const background = $imageEl.attr('data-background');
      const src = $imageEl.attr('data-src');
      const srcset = $imageEl.attr('data-srcset');
      const sizes = $imageEl.attr('data-sizes');

      swiper.loadImage($imageEl[0], (src || background), srcset, sizes, false, () => {
        if (typeof swiper === 'undefined' || swiper === null || !swiper || (swiper && !swiper.params) || swiper.destroyed) return;
        if (background) {
          $imageEl.css('background-image', `url("${background}")`);
          $imageEl.removeAttr('data-background');
        } else {
          if (srcset) {
            $imageEl.attr('srcset', srcset);
            $imageEl.removeAttr('data-srcset');
          }
          if (sizes) {
            $imageEl.attr('sizes', sizes);
            $imageEl.removeAttr('data-sizes');
          }
          if (src) {
            $imageEl.attr('src', src);
            $imageEl.removeAttr('data-src');
          }
        }

        $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
        $slideEl.find(`.${params.preloaderClass}`).remove();
        if (swiper.params.loop && loadInDuplicate) {
          const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');
          if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
            const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index="${slideOriginalIndex}"]:not(.${swiper.params.slideDuplicateClass})`);
            swiper.lazy.loadInSlide(originalSlide.index(), false);
          } else {
            const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index="${slideOriginalIndex}"]`);
            swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
          }
        }
        swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);
      });

      swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
    });
  },
  load() {
    const swiper = this;
    const {
      $wrapperEl, params: swiperParams, slides, activeIndex,
    } = swiper;
    const isVirtual = swiper.virtual && swiperParams.virtual.enabled;
    const params = swiperParams.lazy;

    let slidesPerView = swiperParams.slidesPerView;
    if (slidesPerView === 'auto') {
      slidesPerView = 0;
    }

    function slideExist(index) {
      if (isVirtual) {
        if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index="${index}"]`).length) {
          return true;
        }
      } else if (slides[index]) return true;
      return false;
    }
    function slideIndex(slideEl) {
      if (isVirtual) {
        return $(slideEl).attr('data-swiper-slide-index');
      }
      return $(slideEl).index();
    }

    if (!swiper.lazy.initialImageLoaded) swiper.lazy.initialImageLoaded = true;
    if (swiper.params.watchSlidesVisibility) {
      $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each((elIndex, slideEl) => {
        const index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();
        swiper.lazy.loadInSlide(index);
      });
    } else if (slidesPerView > 1) {
      for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
        if (slideExist(i)) swiper.lazy.loadInSlide(i);
      }
    } else {
      swiper.lazy.loadInSlide(activeIndex);
    }
    if (params.loadPrevNext) {
      if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {
        const amount = params.loadPrevNextAmount;
        const spv = slidesPerView;
        const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
        const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
        // Next Slides
        for (let i = activeIndex + slidesPerView; i < maxIndex; i += 1) {
          if (slideExist(i)) swiper.lazy.loadInSlide(i);
        }
        // Prev Slides
        for (let i = minIndex; i < activeIndex; i += 1) {
          if (slideExist(i)) swiper.lazy.loadInSlide(i);
        }
      } else {
        const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);
        if (nextSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(nextSlide));

        const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);
        if (prevSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(prevSlide));
      }
    }
  },
};

var Lazy$1 = {
  name: 'lazy',
  params: {
    lazy: {
      enabled: false,
      loadPrevNext: false,
      loadPrevNextAmount: 1,
      loadOnTransitionStart: false,

      elementClass: 'swiper-lazy',
      loadingClass: 'swiper-lazy-loading',
      loadedClass: 'swiper-lazy-loaded',
      preloaderClass: 'swiper-lazy-preloader',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      lazy: {
        initialImageLoaded: false,
        load: Lazy.load.bind(swiper),
        loadInSlide: Lazy.loadInSlide.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
        swiper.params.preloadImages = false;
      }
    },
    init() {
      const swiper = this;
      if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
        swiper.lazy.load();
      }
    },
    scroll() {
      const swiper = this;
      if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
        swiper.lazy.load();
      }
    },
    resize() {
      const swiper = this;
      if (swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    },
    scrollbarDragMove() {
      const swiper = this;
      if (swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    },
    transitionStart() {
      const swiper = this;
      if (swiper.params.lazy.enabled) {
        if (swiper.params.lazy.loadOnTransitionStart || (!swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded)) {
          swiper.lazy.load();
        }
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
        swiper.lazy.load();
      }
    },
  },
};

/* eslint no-bitwise: ["error", { "allow": [">>"] }] */

const Controller = {
  LinearSpline: function LinearSpline(x, y) {
    const binarySearch = (function search() {
      let maxIndex;
      let minIndex;
      let guess;
      return (array, val) => {
        minIndex = -1;
        maxIndex = array.length;
        while (maxIndex - minIndex > 1) {
          guess = maxIndex + minIndex >> 1;
          if (array[guess] <= val) {
            minIndex = guess;
          } else {
            maxIndex = guess;
          }
        }
        return maxIndex;
      };
    }());
    this.x = x;
    this.y = y;
    this.lastIndex = x.length - 1;
    // Given an x value (x2), return the expected y2 value:
    // (x1,y1) is the known point before given value,
    // (x3,y3) is the known point after given value.
    let i1;
    let i3;

    this.interpolate = function interpolate(x2) {
      if (!x2) return 0;

      // Get the indexes of x1 and x3 (the array indexes before and after given x2):
      i3 = binarySearch(this.x, x2);
      i1 = i3 - 1;

      // We have our indexes i1 & i3, so we can calculate already:
      // y2 := ((x2x1)  (y3y1))  (x3x1) + y1
      return (((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1])) + this.y[i1];
    };
    return this;
  },
  // xxx: for now i will just save one spline function to to
  getInterpolateFunction(c) {
    const swiper = this;
    if (!swiper.controller.spline) {
      swiper.controller.spline = swiper.params.loop
        ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid)
        : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
    }
  },
  setTranslate(setTranslate, byController) {
    const swiper = this;
    const controlled = swiper.controller.control;
    let multiplier;
    let controlledTranslate;
    function setControlledTranslate(c) {
      // this will create an Interpolate function based on the snapGrids
      // x is the Grid of the scrolled scroller and y will be the controlled scroller
      // it makes sense to create this only once and recall it for the interpolation
      // the function does a lot of value caching for performance
      const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
      if (swiper.params.controller.by === 'slide') {
        swiper.controller.getInterpolateFunction(c);
        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
        // but it did not work out
        controlledTranslate = -swiper.controller.spline.interpolate(-translate);
      }

      if (!controlledTranslate || swiper.params.controller.by === 'container') {
        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
        controlledTranslate = ((translate - swiper.minTranslate()) * multiplier) + c.minTranslate();
      }

      if (swiper.params.controller.inverse) {
        controlledTranslate = c.maxTranslate() - controlledTranslate;
      }
      c.updateProgress(controlledTranslate);
      c.setTranslate(controlledTranslate, swiper);
      c.updateActiveIndex();
      c.updateSlidesClasses();
    }
    if (Array.isArray(controlled)) {
      for (let i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof swiper_esm_bundle_Swiper) {
          setControlledTranslate(controlled[i]);
        }
      }
    } else if (controlled instanceof swiper_esm_bundle_Swiper && byController !== controlled) {
      setControlledTranslate(controlled);
    }
  },
  setTransition(duration, byController) {
    const swiper = this;
    const controlled = swiper.controller.control;
    let i;
    function setControlledTransition(c) {
      c.setTransition(duration, swiper);
      if (duration !== 0) {
        c.transitionStart();
        if (c.params.autoHeight) {
          Utils.nextTick(() => {
            c.updateAutoHeight();
          });
        }
        c.$wrapperEl.transitionEnd(() => {
          if (!controlled) return;
          if (c.params.loop && swiper.params.controller.by === 'slide') {
            c.loopFix();
          }
          c.transitionEnd();
        });
      }
    }
    if (Array.isArray(controlled)) {
      for (i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof swiper_esm_bundle_Swiper) {
          setControlledTransition(controlled[i]);
        }
      }
    } else if (controlled instanceof swiper_esm_bundle_Swiper && byController !== controlled) {
      setControlledTransition(controlled);
    }
  },
};
var Controller$1 = {
  name: 'controller',
  params: {
    controller: {
      control: undefined,
      inverse: false,
      by: 'slide', // or 'container'
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      controller: {
        control: swiper.params.controller.control,
        getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),
        setTranslate: Controller.setTranslate.bind(swiper),
        setTransition: Controller.setTransition.bind(swiper),
      },
    });
  },
  on: {
    update() {
      const swiper = this;
      if (!swiper.controller.control) return;
      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    resize() {
      const swiper = this;
      if (!swiper.controller.control) return;
      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    observerUpdate() {
      const swiper = this;
      if (!swiper.controller.control) return;
      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    setTranslate(translate, byController) {
      const swiper = this;
      if (!swiper.controller.control) return;
      swiper.controller.setTranslate(translate, byController);
    },
    setTransition(duration, byController) {
      const swiper = this;
      if (!swiper.controller.control) return;
      swiper.controller.setTransition(duration, byController);
    },
  },
};

const a11y = {
  makeElFocusable($el) {
    $el.attr('tabIndex', '0');
    return $el;
  },
  addElRole($el, role) {
    $el.attr('role', role);
    return $el;
  },
  addElLabel($el, label) {
    $el.attr('aria-label', label);
    return $el;
  },
  disableEl($el) {
    $el.attr('aria-disabled', true);
    return $el;
  },
  enableEl($el) {
    $el.attr('aria-disabled', false);
    return $el;
  },
  onEnterKey(e) {
    const swiper = this;
    const params = swiper.params.a11y;
    if (e.keyCode !== 13) return;
    const $targetEl = $(e.target);
    if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
      if (!(swiper.isEnd && !swiper.params.loop)) {
        swiper.slideNext();
      }
      if (swiper.isEnd) {
        swiper.a11y.notify(params.lastSlideMessage);
      } else {
        swiper.a11y.notify(params.nextSlideMessage);
      }
    }
    if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
      if (!(swiper.isBeginning && !swiper.params.loop)) {
        swiper.slidePrev();
      }
      if (swiper.isBeginning) {
        swiper.a11y.notify(params.firstSlideMessage);
      } else {
        swiper.a11y.notify(params.prevSlideMessage);
      }
    }
    if (swiper.pagination && $targetEl.is(`.${swiper.params.pagination.bulletClass}`)) {
      $targetEl[0].click();
    }
  },
  notify(message) {
    const swiper = this;
    const notification = swiper.a11y.liveRegion;
    if (notification.length === 0) return;
    notification.html('');
    notification.html(message);
  },
  updateNavigation() {
    const swiper = this;

    if (swiper.params.loop) return;
    const { $nextEl, $prevEl } = swiper.navigation;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        swiper.a11y.disableEl($prevEl);
      } else {
        swiper.a11y.enableEl($prevEl);
      }
    }
    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        swiper.a11y.disableEl($nextEl);
      } else {
        swiper.a11y.enableEl($nextEl);
      }
    }
  },
  updatePagination() {
    const swiper = this;
    const params = swiper.params.a11y;
    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.bullets.each((bulletIndex, bulletEl) => {
        const $bulletEl = $(bulletEl);
        swiper.a11y.makeElFocusable($bulletEl);
        swiper.a11y.addElRole($bulletEl, 'button');
        swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/{{index}}/, $bulletEl.index() + 1));
      });
    }
  },
  init() {
    const swiper = this;

    swiper.$el.append(swiper.a11y.liveRegion);

    // Navigation
    const params = swiper.params.a11y;
    let $nextEl;
    let $prevEl;
    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }
    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }
    if ($nextEl) {
      swiper.a11y.makeElFocusable($nextEl);
      swiper.a11y.addElRole($nextEl, 'button');
      swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
      $nextEl.on('keydown', swiper.a11y.onEnterKey);
    }
    if ($prevEl) {
      swiper.a11y.makeElFocusable($prevEl);
      swiper.a11y.addElRole($prevEl, 'button');
      swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
      $prevEl.on('keydown', swiper.a11y.onEnterKey);
    }

    // Pagination
    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.$el.on('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);
    }
  },
  destroy() {
    const swiper = this;
    if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) swiper.a11y.liveRegion.remove();

    let $nextEl;
    let $prevEl;
    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }
    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }
    if ($nextEl) {
      $nextEl.off('keydown', swiper.a11y.onEnterKey);
    }
    if ($prevEl) {
      $prevEl.off('keydown', swiper.a11y.onEnterKey);
    }

    // Pagination
    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.$el.off('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);
    }
  },
};
var A11y = {
  name: 'a11y',
  params: {
    a11y: {
      enabled: true,
      notificationClass: 'swiper-notification',
      prevSlideMessage: 'Previous slide',
      nextSlideMessage: 'Next slide',
      firstSlideMessage: 'This is the first slide',
      lastSlideMessage: 'This is the last slide',
      paginationBulletMessage: 'Go to slide {{index}}',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      a11y: {
        liveRegion: $(`<span class="${swiper.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`),
      },
    });
    Object.keys(a11y).forEach((methodName) => {
      swiper.a11y[methodName] = a11y[methodName].bind(swiper);
    });
  },
  on: {
    init() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.init();
      swiper.a11y.updateNavigation();
    },
    toEdge() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updateNavigation();
    },
    fromEdge() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updateNavigation();
    },
    paginationUpdate() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updatePagination();
    },
    destroy() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.destroy();
    },
  },
};

const History = {
  init() {
    const swiper = this;
    if (!swiper.params.history) return;
    if (!ssr_window_esm_win.history || !ssr_window_esm_win.history.pushState) {
      swiper.params.history.enabled = false;
      swiper.params.hashNavigation.enabled = true;
      return;
    }
    const history = swiper.history;
    history.initialized = true;
    history.paths = History.getPathValues();
    if (!history.paths.key && !history.paths.value) return;
    history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);
    if (!swiper.params.history.replaceState) {
      ssr_window_esm_win.addEventListener('popstate', swiper.history.setHistoryPopState);
    }
  },
  destroy() {
    const swiper = this;
    if (!swiper.params.history.replaceState) {
      ssr_window_esm_win.removeEventListener('popstate', swiper.history.setHistoryPopState);
    }
  },
  setHistoryPopState() {
    const swiper = this;
    swiper.history.paths = History.getPathValues();
    swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);
  },
  getPathValues() {
    const pathArray = ssr_window_esm_win.location.pathname.slice(1).split('/').filter((part) => part !== '');
    const total = pathArray.length;
    const key = pathArray[total - 2];
    const value = pathArray[total - 1];
    return { key, value };
  },
  setHistory(key, index) {
    const swiper = this;
    if (!swiper.history.initialized || !swiper.params.history.enabled) return;
    const slide = swiper.slides.eq(index);
    let value = History.slugify(slide.attr('data-history'));
    if (!ssr_window_esm_win.location.pathname.includes(key)) {
      value = `${key}/${value}`;
    }
    const currentState = ssr_window_esm_win.history.state;
    if (currentState && currentState.value === value) {
      return;
    }
    if (swiper.params.history.replaceState) {
      ssr_window_esm_win.history.replaceState({ value }, null, value);
    } else {
      ssr_window_esm_win.history.pushState({ value }, null, value);
    }
  },
  slugify(text) {
    return text.toString()
      .replace(/\s+/g, '-')
      .replace(/[^\w-]+/g, '')
      .replace(/--+/g, '-')
      .replace(/^-+/, '')
      .replace(/-+$/, '');
  },
  scrollToSlide(speed, value, runCallbacks) {
    const swiper = this;
    if (value) {
      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
        const slide = swiper.slides.eq(i);
        const slideHistory = History.slugify(slide.attr('data-history'));
        if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
          const index = slide.index();
          swiper.slideTo(index, speed, runCallbacks);
        }
      }
    } else {
      swiper.slideTo(0, speed, runCallbacks);
    }
  },
};

var History$1 = {
  name: 'history',
  params: {
    history: {
      enabled: false,
      replaceState: false,
      key: 'slides',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      history: {
        init: History.init.bind(swiper),
        setHistory: History.setHistory.bind(swiper),
        setHistoryPopState: History.setHistoryPopState.bind(swiper),
        scrollToSlide: History.scrollToSlide.bind(swiper),
        destroy: History.destroy.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.history.enabled) {
        swiper.history.init();
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.params.history.enabled) {
        swiper.history.destroy();
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.history.initialized) {
        swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
      }
    },
  },
};

const HashNavigation = {
  onHashCange() {
    const swiper = this;
    const newHash = ssr_window_esm_doc.location.hash.replace('#', '');
    const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');
    if (newHash !== activeSlideHash) {
      const newIndex = swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-hash="${newHash}"]`).index();
      if (typeof newIndex === 'undefined') return;
      swiper.slideTo(newIndex);
    }
  },
  setHash() {
    const swiper = this;
    if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) return;
    if (swiper.params.hashNavigation.replaceState && ssr_window_esm_win.history && ssr_window_esm_win.history.replaceState) {
      ssr_window_esm_win.history.replaceState(null, null, (`#${swiper.slides.eq(swiper.activeIndex).attr('data-hash')}` || ''));
    } else {
      const slide = swiper.slides.eq(swiper.activeIndex);
      const hash = slide.attr('data-hash') || slide.attr('data-history');
      ssr_window_esm_doc.location.hash = hash || '';
    }
  },
  init() {
    const swiper = this;
    if (!swiper.params.hashNavigation.enabled || (swiper.params.history && swiper.params.history.enabled)) return;
    swiper.hashNavigation.initialized = true;
    const hash = ssr_window_esm_doc.location.hash.replace('#', '');
    if (hash) {
      const speed = 0;
      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
        const slide = swiper.slides.eq(i);
        const slideHash = slide.attr('data-hash') || slide.attr('data-history');
        if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
          const index = slide.index();
          swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
        }
      }
    }
    if (swiper.params.hashNavigation.watchState) {
      $(ssr_window_esm_win).on('hashchange', swiper.hashNavigation.onHashCange);
    }
  },
  destroy() {
    const swiper = this;
    if (swiper.params.hashNavigation.watchState) {
      $(ssr_window_esm_win).off('hashchange', swiper.hashNavigation.onHashCange);
    }
  },
};
var HashNavigation$1 = {
  name: 'hash-navigation',
  params: {
    hashNavigation: {
      enabled: false,
      replaceState: false,
      watchState: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      hashNavigation: {
        initialized: false,
        init: HashNavigation.init.bind(swiper),
        destroy: HashNavigation.destroy.bind(swiper),
        setHash: HashNavigation.setHash.bind(swiper),
        onHashCange: HashNavigation.onHashCange.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.hashNavigation.enabled) {
        swiper.hashNavigation.init();
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.params.hashNavigation.enabled) {
        swiper.hashNavigation.destroy();
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.hashNavigation.initialized) {
        swiper.hashNavigation.setHash();
      }
    },
  },
};

/* eslint no-underscore-dangle: "off" */

const Autoplay = {
  run() {
    const swiper = this;
    const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
    let delay = swiper.params.autoplay.delay;
    if ($activeSlideEl.attr('data-swiper-autoplay')) {
      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
    }
    clearTimeout(swiper.autoplay.timeout);
    swiper.autoplay.timeout = Utils.nextTick(() => {
      if (swiper.params.autoplay.reverseDirection) {
        if (swiper.params.loop) {
          swiper.loopFix();
          swiper.slidePrev(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.isBeginning) {
          swiper.slidePrev(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else {
          swiper.autoplay.stop();
        }
      } else if (swiper.params.loop) {
        swiper.loopFix();
        swiper.slideNext(swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else if (!swiper.isEnd) {
        swiper.slideNext(swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else if (!swiper.params.autoplay.stopOnLastSlide) {
        swiper.slideTo(0, swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else {
        swiper.autoplay.stop();
      }
    }, delay);
  },
  start() {
    const swiper = this;
    if (typeof swiper.autoplay.timeout !== 'undefined') return false;
    if (swiper.autoplay.running) return false;
    swiper.autoplay.running = true;
    swiper.emit('autoplayStart');
    swiper.autoplay.run();
    return true;
  },
  stop() {
    const swiper = this;
    if (!swiper.autoplay.running) return false;
    if (typeof swiper.autoplay.timeout === 'undefined') return false;

    if (swiper.autoplay.timeout) {
      clearTimeout(swiper.autoplay.timeout);
      swiper.autoplay.timeout = undefined;
    }
    swiper.autoplay.running = false;
    swiper.emit('autoplayStop');
    return true;
  },
  pause(speed) {
    const swiper = this;
    if (!swiper.autoplay.running) return;
    if (swiper.autoplay.paused) return;
    if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);
    swiper.autoplay.paused = true;
    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
      swiper.autoplay.paused = false;
      swiper.autoplay.run();
    } else {
      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
    }
  },
};

var Autoplay$1 = {
  name: 'autoplay',
  params: {
    autoplay: {
      enabled: false,
      delay: 3000,
      waitForTransition: true,
      disableOnInteraction: true,
      stopOnLastSlide: false,
      reverseDirection: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      autoplay: {
        running: false,
        paused: false,
        run: Autoplay.run.bind(swiper),
        start: Autoplay.start.bind(swiper),
        stop: Autoplay.stop.bind(swiper),
        pause: Autoplay.pause.bind(swiper),
        onTransitionEnd(e) {
          if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
          swiper.autoplay.paused = false;
          if (!swiper.autoplay.running) {
            swiper.autoplay.stop();
          } else {
            swiper.autoplay.run();
          }
        },
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.autoplay.enabled) {
        swiper.autoplay.start();
      }
    },
    beforeTransitionStart(speed, internal) {
      const swiper = this;
      if (swiper.autoplay.running) {
        if (internal || !swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.pause(speed);
        } else {
          swiper.autoplay.stop();
        }
      }
    },
    sliderFirstMove() {
      const swiper = this;
      if (swiper.autoplay.running) {
        if (swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.stop();
        } else {
          swiper.autoplay.pause();
        }
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.autoplay.running) {
        swiper.autoplay.stop();
      }
    },
  },
};

const Fade = {
  setTranslate() {
    const swiper = this;
    const { slides } = swiper;
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = swiper.slides.eq(i);
      const offset = $slideEl[0].swiperSlideOffset;
      let tx = -offset;
      if (!swiper.params.virtualTranslate) tx -= swiper.translate;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
      }
      const slideOpacity = swiper.params.fadeEffect.crossFade
        ? Math.max(1 - Math.abs($slideEl[0].progress), 0)
        : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
      $slideEl
        .css({
          opacity: slideOpacity,
        })
        .transform(`translate3d(${tx}px, ${ty}px, 0px)`);
    }
  },
  setTransition(duration) {
    const swiper = this;
    const { slides, $wrapperEl } = swiper;
    slides.transition(duration);
    if (swiper.params.virtualTranslate && duration !== 0) {
      let eventTriggered = false;
      slides.transitionEnd(() => {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return;
        eventTriggered = true;
        swiper.animating = false;
        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
        for (let i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  },
};

var EffectFade = {
  name: 'effect-fade',
  params: {
    fadeEffect: {
      crossFade: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      fadeEffect: {
        setTranslate: Fade.setTranslate.bind(swiper),
        setTransition: Fade.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'fade') return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}fade`);
      const overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'fade') return;
      swiper.fadeEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'fade') return;
      swiper.fadeEffect.setTransition(duration);
    },
  },
};

const Cube = {
  setTranslate() {
    const swiper = this;
    const {
      $el, $wrapperEl, slides, width: swiperWidth, height: swiperHeight, rtlTranslate: rtl, size: swiperSize,
    } = swiper;
    const params = swiper.params.cubeEffect;
    const isHorizontal = swiper.isHorizontal();
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let wrapperRotate = 0;
    let $cubeShadowEl;
    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');
        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
          $wrapperEl.append($cubeShadowEl);
        }
        $cubeShadowEl.css({ height: `${swiperWidth}px` });
      } else {
        $cubeShadowEl = $el.find('.swiper-cube-shadow');
        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
          $el.append($cubeShadowEl);
        }
      }
    }
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      let slideIndex = i;
      if (isVirtual) {
        slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
      }
      let slideAngle = slideIndex * 90;
      let round = Math.floor(slideAngle / 360);
      if (rtl) {
        slideAngle = -slideAngle;
        round = Math.floor(-slideAngle / 360);
      }
      const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      let tx = 0;
      let ty = 0;
      let tz = 0;
      if (slideIndex % 4 === 0) {
        tx = -round * 4 * swiperSize;
        tz = 0;
      } else if ((slideIndex - 1) % 4 === 0) {
        tx = 0;
        tz = -round * 4 * swiperSize;
      } else if ((slideIndex - 2) % 4 === 0) {
        tx = swiperSize + (round * 4 * swiperSize);
        tz = swiperSize;
      } else if ((slideIndex - 3) % 4 === 0) {
        tx = -swiperSize;
        tz = (3 * swiperSize) + (swiperSize * 4 * round);
      }
      if (rtl) {
        tx = -tx;
      }

      if (!isHorizontal) {
        ty = tx;
        tx = 0;
      }

      const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
      if (progress <= 1 && progress > -1) {
        wrapperRotate = (slideIndex * 90) + (progress * 90);
        if (rtl) wrapperRotate = (-slideIndex * 90) - (progress * 90);
      }
      $slideEl.transform(transform);
      if (params.slideShadows) {
        // Set shadows
        let shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
        if (shadowBefore.length === 0) {
          shadowBefore = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
          $slideEl.append(shadowBefore);
        }
        if (shadowAfter.length === 0) {
          shadowAfter = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
          $slideEl.append(shadowAfter);
        }
        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
      }
    }
    $wrapperEl.css({
      '-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,
      '-moz-transform-origin': `50% 50% -${swiperSize / 2}px`,
      '-ms-transform-origin': `50% 50% -${swiperSize / 2}px`,
      'transform-origin': `50% 50% -${swiperSize / 2}px`,
    });

    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl.transform(`translate3d(0px, ${(swiperWidth / 2) + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`);
      } else {
        const shadowAngle = Math.abs(wrapperRotate) - (Math.floor(Math.abs(wrapperRotate) / 90) * 90);
        const multiplier = 1.5 - (
          (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2)
          + (Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2)
        );
        const scale1 = params.shadowScale;
        const scale2 = params.shadowScale / multiplier;
        const offset = params.shadowOffset;
        $cubeShadowEl.transform(`scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${(swiperHeight / 2) + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`);
      }
    }
    const zFactor = (swiper_esm_bundle_Browser.isSafari || swiper_esm_bundle_Browser.isUiWebView) ? (-swiperSize / 2) : 0;
    $wrapperEl
      .transform(`translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`);
  },
  setTransition(duration) {
    const swiper = this;
    const { $el, slides } = swiper;
    slides
      .transition(duration)
      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
      .transition(duration);
    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
      $el.find('.swiper-cube-shadow').transition(duration);
    }
  },
};

var EffectCube = {
  name: 'effect-cube',
  params: {
    cubeEffect: {
      slideShadows: true,
      shadow: true,
      shadowOffset: 20,
      shadowScale: 0.94,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      cubeEffect: {
        setTranslate: Cube.setTranslate.bind(swiper),
        setTransition: Cube.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'cube') return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}cube`);
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
      const overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        resistanceRatio: 0,
        spaceBetween: 0,
        centeredSlides: false,
        virtualTranslate: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'cube') return;
      swiper.cubeEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'cube') return;
      swiper.cubeEffect.setTransition(duration);
    },
  },
};

const Flip = {
  setTranslate() {
    const swiper = this;
    const { slides, rtlTranslate: rtl } = swiper;
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      let progress = $slideEl[0].progress;
      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      }
      const offset = $slideEl[0].swiperSlideOffset;
      const rotate = -180 * progress;
      let rotateY = rotate;
      let rotateX = 0;
      let tx = -offset;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
        rotateX = -rotateY;
        rotateY = 0;
      } else if (rtl) {
        rotateY = -rotateY;
      }

      $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;

      if (swiper.params.flipEffect.slideShadows) {
        // Set shadows
        let shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
        if (shadowBefore.length === 0) {
          shadowBefore = $(`<div class="swiper-slide-shadow-${swiper.isHorizontal() ? 'left' : 'top'}"></div>`);
          $slideEl.append(shadowBefore);
        }
        if (shadowAfter.length === 0) {
          shadowAfter = $(`<div class="swiper-slide-shadow-${swiper.isHorizontal() ? 'right' : 'bottom'}"></div>`);
          $slideEl.append(shadowAfter);
        }
        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
      }
      $slideEl
        .transform(`translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`);
    }
  },
  setTransition(duration) {
    const swiper = this;
    const { slides, activeIndex, $wrapperEl } = swiper;
    slides
      .transition(duration)
      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
      .transition(duration);
    if (swiper.params.virtualTranslate && duration !== 0) {
      let eventTriggered = false;
      // eslint-disable-next-line
      slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return;
        // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;
        eventTriggered = true;
        swiper.animating = false;
        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
        for (let i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  },
};

var EffectFlip = {
  name: 'effect-flip',
  params: {
    flipEffect: {
      slideShadows: true,
      limitRotation: true,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      flipEffect: {
        setTranslate: Flip.setTranslate.bind(swiper),
        setTransition: Flip.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'flip') return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}flip`);
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
      const overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'flip') return;
      swiper.flipEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'flip') return;
      swiper.flipEffect.setTransition(duration);
    },
  },
};

const Coverflow = {
  setTranslate() {
    const swiper = this;
    const {
      width: swiperWidth, height: swiperHeight, slides, $wrapperEl, slidesSizesGrid,
    } = swiper;
    const params = swiper.params.coverflowEffect;
    const isHorizontal = swiper.isHorizontal();
    const transform = swiper.translate;
    const center = isHorizontal ? -transform + (swiperWidth / 2) : -transform + (swiperHeight / 2);
    const rotate = isHorizontal ? params.rotate : -params.rotate;
    const translate = params.depth;
    // Each slide offset from center
    for (let i = 0, length = slides.length; i < length; i += 1) {
      const $slideEl = slides.eq(i);
      const slideSize = slidesSizesGrid[i];
      const slideOffset = $slideEl[0].swiperSlideOffset;
      const offsetMultiplier = ((center - slideOffset - (slideSize / 2)) / slideSize) * params.modifier;

      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
      // var rotateZ = 0
      let translateZ = -translate * Math.abs(offsetMultiplier);

      let translateY = isHorizontal ? 0 : params.stretch * (offsetMultiplier);
      let translateX = isHorizontal ? params.stretch * (offsetMultiplier) : 0;

      // Fix for ultra small values
      if (Math.abs(translateX) < 0.001) translateX = 0;
      if (Math.abs(translateY) < 0.001) translateY = 0;
      if (Math.abs(translateZ) < 0.001) translateZ = 0;
      if (Math.abs(rotateY) < 0.001) rotateY = 0;
      if (Math.abs(rotateX) < 0.001) rotateX = 0;

      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;

      $slideEl.transform(slideTransform);
      $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
      if (params.slideShadows) {
        // Set shadows
        let $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
        if ($shadowBeforeEl.length === 0) {
          $shadowBeforeEl = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
          $slideEl.append($shadowBeforeEl);
        }
        if ($shadowAfterEl.length === 0) {
          $shadowAfterEl = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
          $slideEl.append($shadowAfterEl);
        }
        if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
        if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0;
      }
    }

    // Set correct perspective for IE10
    if (swiper_esm_bundle_Support.pointerEvents || swiper_esm_bundle_Support.prefixedPointerEvents) {
      const ws = $wrapperEl[0].style;
      ws.perspectiveOrigin = `${center}px 50%`;
    }
  },
  setTransition(duration) {
    const swiper = this;
    swiper.slides
      .transition(duration)
      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
      .transition(duration);
  },
};

var EffectCoverflow = {
  name: 'effect-coverflow',
  params: {
    coverflowEffect: {
      rotate: 50,
      stretch: 0,
      depth: 100,
      modifier: 1,
      slideShadows: true,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      coverflowEffect: {
        setTranslate: Coverflow.setTranslate.bind(swiper),
        setTransition: Coverflow.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'coverflow') return;

      swiper.classNames.push(`${swiper.params.containerModifierClass}coverflow`);
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);

      swiper.params.watchSlidesProgress = true;
      swiper.originalParams.watchSlidesProgress = true;
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'coverflow') return;
      swiper.coverflowEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'coverflow') return;
      swiper.coverflowEffect.setTransition(duration);
    },
  },
};

const Thumbs = {
  init() {
    const swiper = this;
    const { thumbs: thumbsParams } = swiper.params;
    const SwiperClass = swiper.constructor;
    if (thumbsParams.swiper instanceof SwiperClass) {
      swiper.thumbs.swiper = thumbsParams.swiper;
      Utils.extend(swiper.thumbs.swiper.originalParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false,
      });
      Utils.extend(swiper.thumbs.swiper.params, {
        watchSlidesProgress: true,
        slideToClickedSlide: false,
      });
    } else if (Utils.isObject(thumbsParams.swiper)) {
      swiper.thumbs.swiper = new SwiperClass(Utils.extend({}, thumbsParams.swiper, {
        watchSlidesVisibility: true,
        watchSlidesProgress: true,
        slideToClickedSlide: false,
      }));
      swiper.thumbs.swiperCreated = true;
    }
    swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
    swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);
  },
  onThumbClick() {
    const swiper = this;
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper) return;
    const clickedIndex = thumbsSwiper.clickedIndex;
    const clickedSlide = thumbsSwiper.clickedSlide;
    if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;
    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
    let slideToIndex;
    if (thumbsSwiper.params.loop) {
      slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
    } else {
      slideToIndex = clickedIndex;
    }
    if (swiper.params.loop) {
      let currentIndex = swiper.activeIndex;
      if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
        swiper.loopFix();
        // eslint-disable-next-line
        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        currentIndex = swiper.activeIndex;
      }
      const prevIndex = swiper.slides.eq(currentIndex).prevAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
      const nextIndex = swiper.slides.eq(currentIndex).nextAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
      if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;
      else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;
      else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;
      else slideToIndex = prevIndex;
    }
    swiper.slideTo(slideToIndex);
  },
  update(initial) {
    const swiper = this;
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper) return;

    const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto'
      ? thumbsSwiper.slidesPerViewDynamic()
      : thumbsSwiper.params.slidesPerView;

    if (swiper.realIndex !== thumbsSwiper.realIndex) {
      let currentThumbsIndex = thumbsSwiper.activeIndex;
      let newThumbsIndex;
      if (thumbsSwiper.params.loop) {
        if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
          thumbsSwiper.loopFix();
          // eslint-disable-next-line
          thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
          currentThumbsIndex = thumbsSwiper.activeIndex;
        }
        // Find actual thumbs index to slide to
        const prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();
        const nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();
        if (typeof prevThumbsIndex === 'undefined') newThumbsIndex = nextThumbsIndex;
        else if (typeof nextThumbsIndex === 'undefined') newThumbsIndex = prevThumbsIndex;
        else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) newThumbsIndex = currentThumbsIndex;
        else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) newThumbsIndex = nextThumbsIndex;
        else newThumbsIndex = prevThumbsIndex;
      } else {
        newThumbsIndex = swiper.realIndex;
      }
      if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
        if (thumbsSwiper.params.centeredSlides) {
          if (newThumbsIndex > currentThumbsIndex) {
            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
          } else {
            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
          }
        } else if (newThumbsIndex > currentThumbsIndex) {
          newThumbsIndex = newThumbsIndex - slidesPerView + 1;
        }
        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
      }
    }

    // Activate thumbs
    let thumbsToActivate = 1;
    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;

    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
      thumbsToActivate = swiper.params.slidesPerView;
    }

    thumbsSwiper.slides.removeClass(thumbActiveClass);
    if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual) {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        thumbsSwiper.$wrapperEl.children(`[data-swiper-slide-index="${swiper.realIndex + i}"]`).addClass(thumbActiveClass);
      }
    } else {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);
      }
    }
  },
};
var Thumbs$1 = {
  name: 'thumbs',
  params: {
    thumbs: {
      swiper: null,
      slideThumbActiveClass: 'swiper-slide-thumb-active',
      thumbsContainerClass: 'swiper-container-thumbs',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      thumbs: {
        swiper: null,
        init: Thumbs.init.bind(swiper),
        update: Thumbs.update.bind(swiper),
        onThumbClick: Thumbs.onThumbClick.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      const { thumbs } = swiper.params;
      if (!thumbs || !thumbs.swiper) return;
      swiper.thumbs.init();
      swiper.thumbs.update(true);
    },
    slideChange() {
      const swiper = this;
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    update() {
      const swiper = this;
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    resize() {
      const swiper = this;
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    observerUpdate() {
      const swiper = this;
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    setTransition(duration) {
      const swiper = this;
      const thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;
      thumbsSwiper.setTransition(duration);
    },
    beforeDestroy() {
      const swiper = this;
      const thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;
      if (swiper.thumbs.swiperCreated && thumbsSwiper) {
        thumbsSwiper.destroy();
      }
    },
  },
};

// Swiper Class

const components = [
  Device$1,
  Support$1,
  Browser$1,
  Resize,
  Observer$1,
  Virtual$1,
  Keyboard$1,
  Mousewheel$1,
  Navigation$1,
  Pagination$1,
  Scrollbar$1,
  Parallax$1,
  Zoom$1,
  Lazy$1,
  Controller$1,
  A11y,
  History$1,
  HashNavigation$1,
  Autoplay$1,
  EffectFade,
  EffectCube,
  EffectFlip,
  EffectCoverflow,
  Thumbs$1
];

if (typeof swiper_esm_bundle_Swiper.use === 'undefined') {
  swiper_esm_bundle_Swiper.use = swiper_esm_bundle_Swiper.Class.use;
  swiper_esm_bundle_Swiper.installModule = swiper_esm_bundle_Swiper.Class.installModule;
}

swiper_esm_bundle_Swiper.use(components);

/* harmony default export */ var swiper_esm_bundle = (swiper_esm_bundle_Swiper);

// EXTERNAL MODULE: ./node_modules/wowjs/dist/wow.js
var dist_wow = __webpack_require__("q4TV");
var wow_default = /*#__PURE__*/__webpack_require__.n(dist_wow);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/view/HomePage.vue
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ var HomePage = ({
  name: "HomePage",
  data: function data() {
    return {
      swiperList: [{
        img: __webpack_require__("1MxG"),
        path: "",
        title: 'IT1',
        content: ''
      }, {
        img: __webpack_require__("7/Ek"),
        path: "",
        title: 'IT2',
        content: ''
      }, {
        img: __webpack_require__("1MxG"),
        path: "",
        title: 'IT3',
        content: ''
      }, {
        img: __webpack_require__("7/Ek"),
        path: "",
        title: 'IT4',
        content: ''
      }],
      customerList: [{
        logo: __webpack_require__("bhvW"),
        title: "",
        content: ""
      }, {
        logo: __webpack_require__("blpe"),
        title: "",
        content: ""
      }, {
        logo: __webpack_require__("QbkR"),
        title: "",
        content: ""
      }, {
        logo: __webpack_require__("blpe"),
        title: "",
        content: ""
      }, {
        logo: __webpack_require__("bhvW"),
        title: "",
        content: ""
      }, {
        logo: __webpack_require__("QbkR"),
        title: "",
        content: ""
      }, {
        logo: __webpack_require__("blpe"),
        title: "",
        content: ""
      }, {
        logo: __webpack_require__("bhvW"),
        title: "",
        content: ""
      }, {
        logo: __webpack_require__("QbkR"),
        title: "",
        content: ""
      }, {
        logo: __webpack_require__("bhvW"),
        title: "",
        content: ""
      }, {
        logo: __webpack_require__("blpe"),
        title: "",
        content: ""
      }, {
        logo: __webpack_require__("bhvW"),
        title: "",
        content: ""
      }],
      serverList: [{
        logo: __webpack_require__("81Ru"),
        title: "1",
        content: "<p></p>"
      }, {
        logo: __webpack_require__("GY21"),
        title: "2",
        content: "<p></p>"
      }, {
        logo: __webpack_require__("mTCC"),
        title: "3",
        content: "<p>QQ</p>"
      }, {
        logo: __webpack_require__("3HfK"),
        title: "4",
        content: "<p></p>"
      }]
    };
  },
  mounted: function mounted() {
    /* banner-swiper */
    new swiper_esm_bundle(".banner-swiper", {
      loop: true, // 
      effect: 'fade',
      //
      autoplay: {
        delay: 3000,
        stopOnLastSlide: false,
        disableOnInteraction: false
      },
      // 
      pagination: {
        el: ".swiper-pagination",
        clickable: true
      },
      // 
      navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev"
      },
      // 
      lazy: {
        loadPrevNext: true
      },
      observer: true, //swiperswiper
      observeParents: true //swiperswiper
    });
    /* customer-swiper */
    new swiper_esm_bundle(".customer-swiper", {
      loop: true, // 
      slidesPerView: 3,
      //
      autoplay: {
        delay: 3000,
        stopOnLastSlide: false,
        disableOnInteraction: false
      },
      // 
      navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev"
      },
      observer: true, //swiperswiper
      observeParents: true //swiperswiper
    });
    /* wowjs */
    var wow = new dist_wow["WOW"]({
      boxClass: 'wow',
      animateClass: 'animated',
      offset: 0,
      mobile: true,
      live: true
    });
    wow.init();
  }
});
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-df2ad9e8","hasScoped":true,"transformToRequire":{"video":["src","poster"],"source":"src","img":"src","image":"xlink:href"},"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/view/HomePage.vue
var HomePage_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{"id":"HomePage"}},[_c('div',{staticClass:"container-fuild",attrs:{"id":"swiper"}},[_c('div',{staticClass:"swiper-container banner-swiper"},[_c('div',{staticClass:"swiper-wrapper"},_vm._l((_vm.swiperList),function(item,index){return _c('div',{key:index,staticClass:"swiper-slide"},[_c('img',{staticClass:"swiper-lazy",attrs:{"data-src":item.img,"alt":""}}),_vm._v(" "),_c('div',{staticClass:"swiper-lazy-preloader"}),_vm._v(" "),_c('div',{staticClass:"swiper-slide-title"},[_c('h1',[_vm._v(_vm._s(item.title))]),_vm._v(" "),_c('p',[_vm._v(_vm._s(item.content))])])])}),0),_vm._v(" "),_c('div',{staticClass:"swiper-pagination"}),_vm._v(" "),_c('div',{staticClass:"swiper-button-prev"}),_vm._v(" "),_c('div',{staticClass:"swiper-button-next"})])]),_vm._v(" "),_vm._m(0),_vm._v(" "),_vm._m(1),_vm._v(" "),_c('div',{staticClass:"container-fuild",attrs:{"id":"customer"}},[_c('div',{staticClass:"container customer-container"},[_c('p',{staticClass:"customer-title text-center"},[_vm._v("")]),_vm._v(" "),_c('div',{staticClass:"swiper-container customer-swiper hidden-xs"},[_c('div',{staticClass:"swiper-wrapper"},_vm._l((_vm.customerList),function(item,index){return _c('div',{key:index,staticClass:"swiper-slide customer-block"},[_c('div',{staticClass:"customer-logo"},[_c('img',{staticClass:"center-block",attrs:{"src":item.logo,"alt":"logo"}})]),_vm._v(" "),_vm._m(2,true),_vm._v(" "),_c('div',{staticClass:"customer-content1"},[_c('small',[_vm._v(_vm._s(item.content))])]),_vm._v(" "),_c('div',{staticClass:"customer-content2"},[_vm._v(_vm._s(item.title))])])}),0),_vm._v(" "),_c('div',{staticClass:"swiper-button-prev"}),_vm._v(" "),_c('div',{staticClass:"swiper-button-next"})]),_vm._v(" "),_c('div',{staticClass:"row visible-xs customer-block"},_vm._l((_vm.customerList),function(item,index){return _c('div',{key:index,staticClass:"col-xs-12"},[_c('div',{staticClass:"customer-logo"},[_c('img',{staticClass:"center-block",attrs:{"src":item.logo,"alt":"logo"}})]),_vm._v(" "),_vm._m(3,true),_vm._v(" "),_c('div',{staticClass:"customer-content1"},[_c('small',[_vm._v(_vm._s(item.content))])]),_vm._v(" "),_c('div',{staticClass:"customer-content2"},[_c('small',[_vm._v(_vm._s(item.title))])])])}),0)])]),_vm._v(" "),_c('div',{staticClass:"conatiner-fuild",attrs:{"id":"whyChooseUs"}},[_c('div',{staticClass:"container"},[_vm._m(4),_vm._v(" "),_c('div',{staticClass:"row"},_vm._l((_vm.serverList),function(item,index){return _c('div',{key:index,staticClass:"col-xs-12 col-sm-6 col-md-3 server-wrapper"},[_c('div',{staticClass:"server-block wow slideInUp",attrs:{"onmouseenter":"this.style.color='#28f';this.style.borderColor='#28f'","onmouseleave":"this.style.color='#666';this.style.borderColor='#ccc'"}},[_c('img',{staticClass:"center-block",attrs:{"src":item.logo,"alt":"logo"}}),_vm._v(" "),_c('p',{staticClass:"text-center"},[_vm._v(_vm._s(item.title))]),_vm._v(" "),_c('div',{staticClass:"text-center",attrs:{"onmouseenter":"this.style.color='#28f'","onmouseleave":"this.style.color='#ccc'"},domProps:{"innerHTML":_vm._s(item.content)}})])])}),0)])])])}
var staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"container-fuild",attrs:{"id":"bigData"}},[_c('div',{staticClass:"row bigData-container"},[_c('div',{staticClass:"col-xs-12 col-sm-12 col-md-6 wow zoomIn"},[_c('img',{staticClass:"img-responsive",attrs:{"src":__webpack_require__("M3eK"),"alt":""}})]),_vm._v(" "),_c('div',{staticClass:"col-xs-12 col-sm-12 col-md-6"},[_c('h2',{staticClass:"bigData-title"},[_vm._v("\n          \n          "),_c('small',[_vm._v("/ Big Data Management System")])]),_vm._v(" "),_c('p',[_vm._v("")]),_vm._v(" "),_c('p',[_vm._v("")]),_vm._v(" "),_c('h2',{staticClass:"bigData-device"},[_vm._v("PC/PAD/Phone  ")]),_vm._v(" "),_c('a',{staticClass:"btn btn-lg btn-block btn-info",attrs:{"href":"#"}},[_vm._v("")])])])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"container-fuild text-center",attrs:{"id":"contactUs"}},[_c('div',{staticClass:"container contactUs-container wow slideInUp"},[_c('h1',[_vm._v("IT")]),_vm._v(" "),_c('h3',[_vm._v("7x24IT")]),_vm._v(" "),_c('button',{staticClass:"btn btn-default btn-sm",attrs:{"onmouseleave":"this.style.borderColor='#ffffff'; this.style.backgroundColor='#ffffff'; this.style.color='#3f3f3f';","onmouseenter":"this.style.backgroundColor='transparent'; this.style.borderColor='#ffffff'; this.style.color='#ffffff';"}},[_vm._v("")]),_vm._v(" "),_c('div',{staticClass:"contactUs-contactWay"},[_c('span'),_vm._v(" "),_c('span'),_vm._v(" "),_c('span')])])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"customer-yh"},[_c('img',{attrs:{"src":__webpack_require__("TIoG"),"alt":""}})])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"customer-yh"},[_c('img',{attrs:{"src":__webpack_require__("TIoG"),"alt":""}})])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"whyChooseUs-title text-center"},[_c('p',[_vm._v("")]),_vm._v(" "),_c('p',[_vm._v("THE REASON TO CHOOSING US")])])}]
var esExports = { render: HomePage_render, staticRenderFns: staticRenderFns }
/* harmony default export */ var view_HomePage = (esExports);
// CONCATENATED MODULE: ./src/view/HomePage.vue
function injectStyle (ssrContext) {
  __webpack_require__("1SrM")
}
var normalizeComponent = __webpack_require__("VU/8")
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = "data-v-df2ad9e8"
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  HomePage,
  view_HomePage,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ var src_view_HomePage = __webpack_exports__["default"] = (Component.exports);


/***/ })

});
//# sourceMappingURL=1.6ad3bd21ac2227db89b4.js.map